# OS（Operating System）

## 冯诺伊曼体系简介

现代计算机之父**冯诺伊曼**最先提出程序存储的思想，并成功将其运用在计算机的设计之中，该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是**中央处理器（CPU）、内存、输入设备、输出设备、总线。**

![冯诺依曼模型](png\冯诺依曼模型.png)

### 计算机基本结构

**存储器**：代码跟数据在RAM跟ROM中是线性存储， 数据存储的单位是一个二进制位。最小的存储单位是字节。

**总线**：总线是用于 CPU 和内存以及其他设备之间的通信，总线主要有三种：

> 1. `地址总线`：用于指定 CPU 将要操作的内存地址。
> 2. `数据总线`：用于读写内存的数据。
> 3. `控制总线`：用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后响应，这时也需要控制总线。

**输入/输出设备**：输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。比如键盘按键时需要和 CPU 进行交互，这时就需要用到控制总线。

**CPU**：中央处理器，类比人脑，作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。CPU用寄存器存储计算时所需数据，寄存器一般有三种：

> 1. `通用寄存器`：用来存放需要进行运算的数据，比如需进行加法运算的两个数据。
> 2. `程序计数器`：用来存储 CPU 要执行下一条指令所在的内存地址。
> 3. `指令寄存器`：用来存放程序计数器指向的指令本身。

### 指令执行的过程

1. CPU读取程序计数器获得指令内存地址，CPU控制单元操作地址总线从内存地址拿到数据，数据通过数据总线到达CPU被存入指令寄存器。
2. CPU分析指令寄存器中的指令，如果是计算类型的指令交给逻辑运算单元，如果是存储类型的指令交给控制单元执行。
3. CPU 执行完指令后程序计数器的值通过自增指向下个指令，比如32位CPU会自增4。
4. 自增后开始顺序执行下一条指令，不断循环执行直到程序结束。

**CPU位宽**：32位CPU一次可操作计算4个字节，64位CPU一次可操作计算8个字节，这个是硬件级别的。平常我们说的32位或64位操作系统指的是软件级别的，指的是程序中指令多少位。
**线路位宽**：CPU操作指令数据通过高低电压变化进行数据传输，传输时候可以串行传输，也可以并行传输，多少个并行等于多少个位宽。

## 操作系统简介

操作系统，英文名称Operating System，简称OS，是计算机系统中必不可少的基础系统软件，它是应用程序运行以及用户操作必备的基础环境支撑，是计算机系统的核心。是处于用户与计算机系统硬件之间用于传递信息的系统程序软件。例如：操作系统会在接收到用户输入的信息后，将其传给计算机系统硬件核心进行处理，然后再把计算机系统硬件的处理结果返回给使用者。

![操作系统功能模块](png\操作系统功能模块.png)

### 功能模块

操作系统的功能模块是：处理器管理、存储器管理、设备管理、文件管理和作业管理

**进程管理：**进程控制：创建、暂停、唤醒、撤销。进程调度：调度策略、优先级。进程通信：进程间通信。

**存储管理**：内存分配。内存共享。内存保护。虚拟内存。

**设备管理**：设备的分配和调度。设备无关性操作。设备传输控制。设备驱动。

**文件管理：**存储空间管理。文件的操作。目录的操作。文件和目录的存取权限管理。

**作业管理：**负责处理用户提交的任何要求。

## 进程管理

### 进程和线程的调度过程故事

本篇用一个故事说清楚鸿蒙进程和线程的调度过程。

#### 有个场馆

某地有一个演出场馆，分成室内馆(400平米)和室外馆(4万平米)，管理处在室内馆，那是工作人员办公的地方，非工作人员不得进入!

场馆的定位是为本地用户提供舞台表演(统称舞台剧)，规定同时只能一个剧上演，但因为生意太好，申请人太多了，所以用馆要先申请->排队->上演。场馆里面有一座永远很准时，不会停的大钟表，每十分钟就自动响一次，场馆里有很多的资源，有篮球，酒馆，小卖部，桌椅，还有演员(人也算资源)，反正就是应有尽有，但是数量有限。

资源由管理处统一管理，这些资源也得先申请才能使用。场地外有个大屏幕，屏幕实时对外公布场馆舞台剧情况，屏幕内容如下:

```text
 舞台剧名 优先级    状态        进行中节目       就绪节目
 ---------------------------------------------------------
 管理处     0       正在工作    打扫场地卫生        无 
 三国演义   19      已就绪      无              骂死王朗 
 淘宝直播   20      已就绪      无              薇娅9点直播 
```

场馆的内部工作也是个剧，只不过它的内部剧，优先级最高。而且注意这里只展示正在和就绪的剧情节目，就绪是指万事俱备，只欠登台表演的意思。

例如上表中有两个剧都准备好了，排成了一个就绪队列，都等着管理处打扫完卫生后表演，但同时只能演一个剧，而三国演义的优先级更高(场馆规定越小的优先级越高)，所以不出意外，下一个表演的节目就是三国演义之骂死王朗。

这里请记住就绪队列，后续会反复的提它，很重要!

#### 表演走什么流程？

用馆者需提交你舞台剧的剧本，剧本可以是玩游戏，拍电视剧，直播电商等等，反正精彩的世界任你书写，场馆内有专人(统称导演)负责跟进你的剧本上演。

剧本由各种各样的场景剧组成(统称节目)，比如要拍个水浒传的剧本。 被分成武松打虎，西门和金莲那点破事等等节目剧。申请流程是去管理处先填一张电子节目表，节目表有固定的格式，填完点提交你的工作就完成了，接下来就是导演的事了。

节目表单格式如下。

```text
剧名    节目章回  内容          优先级  所需资源            状态 
----------------------------------------------------------------
水浒传  第18回   武松打虎          12   武松，老虎，          未开始 
水浒传  第28回   西门金莲那点破事   2    西门庆，金莲，炕      未开始 
水浒传  第36回   武松拳打蒋门神     14   武松，蒋门神，猪肉    未开始 
```

故事写到这里，大家脑子里有个画面了吧，记住这两张表，继续走起。

#### 西门大官人什么时候表演？

场馆都会给每个用馆单位发个标号代表你使用场馆的优先级，剧本中每个场景节目也有优先级，都是0级最高，31级最低，这里比如水浒传优先级为8，西门庆和金莲那点破事节目为2，节目资源是需要两位主角(西门，金莲)和王婆，一个炕等资源，这些资源要向场馆负责人申请好，节目资源申请到位了就可以进入就绪队列。

如果你的剧本里没有一个节目的资源申请到了那对不起您连排号的资格都没有。这里假如水浒传审核通过，并只有西门大官人节目资源申请成功，而管理处卫生打扫完了，以上两个表格的内容将做如下更新



```text
舞台剧名 优先级    状态        进行中节目       就绪节目
---------------------------------------------------------
水浒传     8       正在工作    西门金莲那点破事        无 
三国演义  19       已就绪      无              骂死王朗 
淘宝直播  20       已就绪      无              薇娅9点直播
```

注意虽然三国演义先来，但此时水浒传排在三国的前面，是因为它的优先级高，优先级分32级，0最高，31最低。

```text
剧名  节目章回  内容        优先级  所需资源        状态        表演位置 
---------------------------------------------------------------------------
水浒传  第18回 武松打虎        12  武松，老虎，酒18碗 未开始         暂无 
水浒传  第28回 西门金莲那点破事 2   西门庆，金莲，炕   正在进行       西门火急火燎的跑进金莲屋内 
水浒传  第36回 武松拳打蒋门神   14  武松，蒋门神，猪肉 未开始         暂无 
```

注意看表中状态的变化和优先级，一个是剧本的优先级，一个是同一个剧本中节目的优先级。而之前优先级最高的管理处，因为没有其他节目要运行，所以移出了就绪队列。

#### 西门好事被破坏了怎么办了？

场馆会根据节目上的内容把节目演完。每个节目十分钟，时间到了要回去重新排队，如果还是你就可以继续你的表演。但这里经常会有异常情况发生。

比如上级领导给场馆来个电话临时有个更高优先级节目要插进来，没办法西门你的好事要先停止，please stop! 场地要让给别人办事，西门灰溜溜得回就绪队列排队去，但请放心会在你西门退场前会记录下来表演到哪个位置了(比如:西门官人已脱完鞋)，以便回来时继续接着表演。高优先级的事处理完后，如果西门的优先级还是最高的就可以继续用场地，会先还原现场演到哪了再继续办事就完了，绝不重复西门前面的准备工作，否则西门绝不答应!

节目表演完所有资源要回收，这个节目从此消亡，如果你剧本里所有节目都表演完了，那你的整个剧本也可以拜拜了，导演回到导演组，又可以去接下一部戏了。

这里还原下西门被场馆紧急电话打断后表的变化是怎样的，如下:

```text
剧本名称 优先级 状态        进行中节目      就绪节目 
---------------------------------------------------------
管理处      0   正在工作    接听上级电话 无 
水浒传      8   已就绪      无          西门和金莲那点破事 
三国演义    19  已就绪      无          骂死王朗 
淘宝直播    20  已就绪      无          薇娅9点直播 
```

```text
剧名    节目章回  内容          优先级  所需资源            状态    表演位置 
-------------------------------------------------------------------------  
水浒传  第18回  武松打虎        12      武松，老虎，酒18碗   未开始     暂无 
水浒传  第28回  西门金莲那点破事 2      西门庆，金莲，一个炕  就绪     西门官人脱完鞋 
水浒传  第36回  武松拳打蒋门神  14      武松，蒋门神，猪肉    未开始     暂无 
```

#### 表演给谁看呢？

外面那些吃瓜观众啊，群众你我他，游戏公司设计了游戏的剧本，电商公司设计了电商剧本，西门大官人被翻拍了这么多次不就是都爱看嘛，场馆会按你的剧本来表演，当然也可以互动，表演的场景需要观众操作时，观众在外面可以操作，发送指令。想想你玩游戏输入名字登录的场景。场馆里面有三个团队，张大爷团队负责导演组演剧本，王场馆负责场地的使用规划的，李后勤负责搞搞后勤。

#### 张大爷团队做什么的？

上面这些工作都是张大爷团队的工作，接待剧本的导演组，管理剧本清单，指派导演跟进，申请节目资源，调整剧本优先级，控制时间，以使舞台能被公平公正的被调度使用等等

#### 王场馆是做什么的？

看名字能知道负责场地用度的，你想想这么多节目，场地只有这么点，同时只能由一个节目上演，怎么合理的规划才能即公平又效率最大化呢，这就是王场馆的工作，但咱王总也有两把刷子，会给用馆公司感觉到整个场馆都是自己在用，具体不在这个故事里说明，后续有专门讲王场馆如何高效的管理内外场地的故事篇。

#### 李后勤是做什么的？

场馆每天的开业，歇业，场地清理，管理处的对外业务，接听电话，有人闹事了怎么处理，收钱开发票 等等也有很多工作统称为后勤工作要有专门的团队来对接，具体不在这里说明，后续也有专门讲这块的故事。

#### 故事想说什么呢？

故事到底想说什么呢？这就是操作系统的调度机制，熟悉了这个故事就熟悉了鸿蒙系统内核任务调度的工作原理！操作系统就是管理场馆和确保工作人员有序工作的系统解决方案商，外面公司只要提供个剧本，就能按剧本把这台戏演好给广大观众观看。有了这个故事垫底，鸿蒙内核源码分析系列就有了一个非常好的开始基础。

#### 内核和故事的关系映射

```text
故事概念        内核概念            备注 
--------------------------------------------------------- 
只能一个剧本演   单CPU           多CPU核指多个剧同时上演  
剧本            程序            一个剧本一个负责人跟进，跑起来的程序叫进程  
导演            进程            进程负责剧本整个运行过程，是资源管理单元，任务也是一种资源 
节目            线程/任务       任务记录节目的整个运行过程，任务是调度的单元 
西门被打断      保存现场        本质是保存寄存器(PC，LR，FP，SP)的状态  
西门继续来      恢复现场        本质是还原寄存器(PC，LR，FP，SP)的状态  
表演场地        用户空间        所有节目都在同一块场地表演  
管理处          内核空间        管理处非工作人员不得入内 
外部场地        磁盘空间        故事暂未涉及，留在内存故事中讲解  
节目内容        代码段          任务涉及的具体代码段  
管理处的服务    系统调用        软中断实现，切换至内核栈  
场馆大钟        系统时钟        十分钟响一次代表一个节拍(tick)  
节目20分钟      时间片          鸿蒙时间片默认 2个tick，20ms 
上级电话        中断            硬中断，直接跳到中断处理函数执行  
表演顺序        优先级          进程和线程都是32个优先级，[0-31]，从高到低  
张大爷          进程/线程管理   抢占式调度，优先级高者运行  
王场馆          内存管理        虚拟内存，内存分配，缺页置换 ==  
李后勤          异常接管        中断，跟踪，异常接管 ==  
```

#### 请牢记这个故事

当然还有很多的细节在故事里没有讲到，比如王场馆和李后勤的工作细节，还有后续故事一一拆解。太细不可能真的在一个故事里全面讲完，笔者想说的是框架，架构思维，要先有整体框架再顺藤摸瓜寻细节，层层深入，否则很容易钻进死胡同里出不来。读着读着就放弃了，其实真没那么难。当你摸清了整个底层的运作机制再看上层的应用，就会有了拨开云雾见阳光，神清气爽的感觉。具体的我们在后续的章节里一一展开，用这个故事去理解鸿蒙系统内核调度过程，没毛病，请务必牢记这个故事。

### **官方基本概念**

- 从系统的角度看，进程是资源管理单元。进程可以使用或等待CPU、使用内存空间等系统资源，并独立于其它进程运行。进程是资源管理单元，注意是管理资源的， 资源是什么？ 内存，任务，文件，信号量等等都是资源。故事篇中对进程做了一个形象的比喻(导演)，负责节目(任务)的演出，负责协调节目运行时所需的各种资源。让节目能高效顺利的完成。
- 进程模块可以给用户提供多个进程，实现了进程之间的切换和通信，帮助用户管理业务程序流程。这样用户可以将更多的精力投入到业务功能的实现中。
- 每一个用户态进程均拥有自己独立的进程空间，相互之间不可见，实现进程间隔离。
-  任务就是线程，是CPU的调度单元。任务是作为一种资源被进程管理的，进程为任务提供内存支持，提供文件支持，提供设备支持。

# [操作系统原理一：进程管理](https://www.cnblogs.com/zhxmdefj/p/12059174.html)

# 进程管理

## 进程[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2018073890)

进程是**程序的一次执行**

是一个程序及其数据在处理机上顺序执行时所发生的活动

是具有独立功能的程序在一个数据集合上的一次运行过程

是系统进行资源分配和调度的一个**基本单位**

是**PCB结构、程序和数据的集合**

**设备分配**只针对**现有进程**，不会创建进程

进程的特征：

- **动态性**：进程的实质是程序的一次执行过程，因此，动态特征是进程最重要的特征
- **并发性**：没有为之建立进程的程序是不能并发执行的，仅当为之建立一个进程后才能参加
  并发执行
- **独立性**：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位
- **异步性**：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可
  预知的速度向前推进
- **结构特征**：为了控制和管理进程，系统为每个进程设立一个进程控制块--PCB

进程与程序的区别：

- **程序是进程的静态文本**，进程是执行程序的动态过程
- **进程与程序之间不是一一对应的**，同一程序同时运行于若干不同的数据集合上，它将属于若干个不同的进程；
  一个进程可以执行多个程序
- 程序可作为软件资源长期保存，**进程只是一次执行过程，是暂时的**
- 进程是系统**分配调度的独立单位**，能与其他进程并发执行

### 进程状态及其演变[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#660159715)

进程执行的间断性，决定了进程可能具有多种状态

#### 基本状态[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2116931942)

运行的进程可能具有**就绪、执行、阻塞**三种基本状态

[![img](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191127212942988-1687319513.png)](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191127212942988-1687319513.png)

当进程已分配到除CPU以外的所有必要资源时，它便处于**就绪状态**，一旦获得CPU，便立即执行，进入**执行状态**
正在执行的进程，由于发生某个事件而暂时无法执行时，便放弃处理机而进入**阻塞状态**
由于执行的进程变为**阻塞状态**后，调度程序立即把处理机分配给另一个就绪进程（因此，阻塞进程的事件消失后，进程不会立即恢复到执行状态，而转变为就绪状态，重新等待处理机）

#### 创建和终止[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#1901920112)

为了管理的需要，还存在着两种比较常见的进程状态，即创建状态和终止状态

[![img](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191127212859878-997669861.png)](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191127212859878-997669861.png)

##### 创建状态：

**引起创建的事件：**

1. 用户登录
2. 作业调度：为被调度的作业创建进程
3. 提供服务：要求打印
4. 应用请求

创建一个进程一般要通过两个步骤：

- 首先，为一个新进程创建PCB，并填写必要的管理信息；
- 其次，把该进程转入就绪状态并插入就绪队列之中。

当一个新进程被创建时，系统已为其分配了PCB，填写了进程标识等信息，但由于该进程所必需的资源或其它信息，如主存资源尚未分配等，一般而言，此时的进程已拥有了自己的PCB，但进程自身还未进入主存，即**创建工作尚未完成，进程还不能被调度运行，其所处的状态就是创建状态。**

引入创建状态，是为了保证进程的调度必须在创建工作完成后进行，以确保对进程控制块操作的完整性。同时，创建状态的引入，也增加了管理的灵活性，操作系统可以根据系统性能或主存容量的限制，推迟创建状态进程的提交。对于**处于创建状态的进程，获得了其所必需的资源，以及对其PCB初始化工作完成后，进程状态便可由创建状态转入就绪状态。**

##### 终止状态：

**引起终止的事件：**

1. 正常结束
2. 异常结束
3. 外界干预
   1. 系统管理员kill
   2. 父进程终止
   3. 父进程请求

进程的终止也要通过两个步骤：

- 首先等待操作系统进行善后处理
- 然后将其PCB清零，并将PCB 空间返还系统

当**一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态**

进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。

#### 阻塞和唤醒[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2203142148)

**阻塞**是进程**自身**的一种主动行为

a. 调用block原语

b. 停止执行，修改PCB进入阻塞队列（一个或多个

**唤醒**由其他相关进程完成

a. wakeup原语

b. 修改PCB进入就绪队列

#### 挂起[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#4142392019)

为了系统和用户观察分析的需要，还引入了**挂起操作**，与挂起对应的是**激活操作**

当进程被挂起，便会进入**静止状态**：正在执行，便会暂停执行，处于就绪状态则不接受调度

引入挂起状态的原因有：

- 终端**用户**的请求：当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态称为挂起状态。
- **父进程**请求：有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。
- **负荷调节**的需要：当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
- 操作**系统**的需要：操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。

在引入挂起状态后：

[![img](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191126204213042-208613052.png)](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191126204213042-208613052.png)

- 活动就绪→静止就绪：当进程处于未被挂起的就绪状态时，称此为活动就绪状态，表示为Readya
  当用挂起原语Suspend 将该进程挂起后，该进程便转变为静止就绪状态，表示为Readys，处于Readys状态的进程不再被调度执行
- 活动阻塞→静止阻塞：当进程处于未被挂起的阻塞状态时，称它是处于活动阻塞状态，表示为Blockeda。当用Suspend原语将它挂起后，进程便转变为静止阻塞状态，表示为Blockeds。处于该状态的进程在其所期待的事件出现后，将从静止阻塞变为静止就绪
- 静止就绪→活动就绪：处于Readys 状态的进程，若用激活原语Active 激活后，该进程将转变为Readya 状态
- 静止阻塞→活动阻塞：处于Blockeds 状态的进程，若用激活原语Active 激活后，该进程将转变为Blockeda 状态

#### 五个进程状态的转换[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#1696803742)

[![img](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191126204641545-1042742502.png)](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191126204641545-1042742502.png)

- NULL→创建：一个新进程产生时，该进程处于创建状态
- 创建→活动就绪：在当前系统的性能和内存的容量均允许的情况下，完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为活动就绪状态
- 创建→静止就绪：考虑到系统当前资源状况和性能要求，并不分配给新建进程所需资源，主要是主存资源，相应的系统进程将进程状态转为静止就绪状态，对换到外存，不再参与调度，此时进程创建工作尚未完成
- 执行→终止：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，进程即进终止状态

### PCB[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#747428542)

为了描述和控制进程的运行，系统为每个进程定义了一个数据结构——**进程控制块PCB(Process Control Block)**，它是进程实体的一部分，是操作系统中最重要的记录型数据结构

PCB 的作用是**使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程**

1. 作为独立运行基本单位的标志
2. 能实现间断性的运行方式
3. 提供进程管理所需要的信息
4. 提供进程调度所需要的信息
5. 实现与其他进程的同步与通信

#### PCB中的信息：[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#1048063495)

1. 进程标识符

   ：用于惟一地标识一个进程，一个进程通常有两种标识符：

   1. 内部标识符，在所有的操作系统中，都为每一个进程赋予了一个惟一的数字标识符，
      它通常是一个进程的序号。设置内部标识符主要是为了方便系统使用。
   2. 外部标识符，它由创建者提供，通常是由字母、数字组成，往往是由用户(进程)在访问该进程时使用。为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可设置用户标识，以指示拥有该进程的用户。

2. 处理机状态

   ：主要是由处理机的各种寄存器中的内容组成的。处理机在运行时，许多信息都放在寄存器中。当处理机被中断时，所有这些信息都必须保存在PCB 中，以便在该进程重新执行时，能从断点继续执行。这些寄存器包括

   1. 通用寄存器，又称为用户可视寄存器，它们是用户程序可以访问的，用于暂存信息，在大多数处理机中，有 8～32 个通用寄存器，在RISC 结构的计算机中可超过100 个
   2. 指令计数器，其中存放了要访问的下一条指令的地址
   3. 程序状态字PSW，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等
   4. 用户栈指针，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址，栈指针指向该栈的栈顶。

3. 进程调度信息

   ：在 PCB中还存放一些与进程调度和进程对换有关的信息，包括

   1. 进程状态，指明进程的当前状态，作为进程调度和对换时的依据
   2. 进程优先级，用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机
   3. 进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等
   4. 事件，指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。

4. 进程控制信息

   ：

   1. 程序和数据的地址，指进程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据
   2. 进程同步和通信机制，指实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB 中
   3. 资源清单，即一张列出了除CPU 以外的、进程所需的全部资源及已经分配到该进程的资源的清单
   4. 链接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。

#### PCB的组织方式[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2065124520)

在一个系统中，通常可拥有数十个、数百个乃至数千个PCB。为了能对它们加以有效的管理，应该用适当的方式将这些PCB组织起来。目前常用的组织方式有以下两种。

1. **线性方式**：将系统种所有PCB都组织在一张线性表中，将该表首地址存在内存的一个专用区域
   实现简单，开销小，但是每次都需要扫描整张表，适合进程数目不多的系统
2. **链接方式**：把同一状态的PCB链接成一个队列，形成就绪队列、若干个阻塞队列和空白队列等
   对其中的就绪队列常按进程优先级的高低排列，优先级高排在队前，此外，也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I/O 操作完成的队列和等待分配内存的队列等
3. **索引方式**：系统根据所有进程的状态建立几张索引表，例如就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中，在每个索引表的表目中，记录具有相应状态的某个PCB在PCB址

[![img](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191126215514155-537695999.png)](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191126215514155-537695999.png)
[![img](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191126215521888-2083124293.png)](https://img2018.cnblogs.com/blog/1536438/201911/1536438-20191126215521888-2083124293.png)

## 进程的控制[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2549135280)

进程控制是进程管理最基本的功能，主要包括创建新进程，终止已完成的进程，将发生异常的进程置于阻塞状态，进程运行中的状态转换等

### 进程创建[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#3820222112)

**参数：**进程标识、优先级、进程起始地址、CPU初始状态、资源需求等等

**创建进程的过程**：

1. 创建一个空白PCB
2. 为新进程分配所需资源
3. 初始化PCB
   1. 标识信息，将系统分配的标识符和父进程标识符填入新PCB
   2. 处理机状态信息，使程序计数器指向程序入口地址，使栈指针指向栈顶
   3. 处理机控制信息，将进程设为就绪/静止状态，通常设为最低优先级
4. 如果就绪队列能接纳，则插入

### 进程终止[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2830205229)

**进程终止的时机/时间：**

1. 正常结束
2. 异常结束
   1. 越界错，访问的存储区越出该进程的区域
   2. 保护错，试图访问不允许访问的资源，或以不适当的方式访问（写只读）
   3. 非法指令，试图执行不存在的指令（可能是程序错误地转移到数据区，数据当成了指令）
   4. 特权指令出错，用户进程试图执行一条只允许OS执行的指令
   5. 运行超时，执行时间超过指定的最大值
   6. 等待超时，进程等待某件事超过指定的最大值
   7. 算数运算错，试图执行被禁止的运算（被0除）
   8. I/O故障
3. 外界干预
   1. 操作员或OS干预（死锁）
   2. 父进程请求，子进程完成父进程指定的任务时
   3. 父进程终止，所有子进程都应该结束

**终止过程**：

1. 根据被终止进程的标识符，从PCB集合中检索出该PCB，读取进程状态
2. 若处于执行状态：立即终止执行，置调度标志为true，指示该进程被终止后重新调度
3. 若进程有子孙进程：将其所有子孙进程终止
4. 全部资源还给父进程/OS
5. PCB从所在队列/链表中移出

### 进程阻塞[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2273625029)

**阻塞的时机/事件**

1. 请求共享资源失败，系统无足够资源分配
2. 等待某种操作完成
3. 新数据尚未到达（相互合作的进程）
4. 等待新任务

**阻塞过程**：进程通过block

### 进程唤醒[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#1527631852)

原语wakeup，和阻塞成对使用

**唤醒过程**：先把被阻塞的进程从该事件阻塞队列移出，将其PSB状态改为就绪，再插入就绪队列

## 进程同步[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2926351464)

### 制约关系[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2057596624)

- 资源共享关系（间接制约
  - 需要互斥的访问临界资源
- 相互合作关系（直接制约

**临界资源**：一次只允许一个进程访问的资源

- 引起**不可再现性**是因为临界资源没有互斥的访问

### 临界区[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#688363739)

```C++
Copywhile(1){
    entry;		//进入区
    critical;	//临界区
    exit;		//退出区
}
```

各进程应互斥进入相关临界区，所谓临界区是指一段代码，一段程序

**同步机制**应该遵循：

- 空闲让进
- 忙则等待
- 有限等待
- 让权等待：不能进入临界区的执行进程**放弃cpu执行权**

### 整形信号量[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2631882794)

信号量机制是一种进程间的**低级**通信方式

s是一个整形量，除了初始化外，**仅通过**两个原子操作wait(s)和signal(s)访问（也叫P，V操作）

```C++
Copywait(s){
	while(s<=0);
    s--;
}
signal(s){
	s++;
}
```

互斥关系：A，B共享一个缓冲区，互斥

```C++
CopyPA(){
    while(1){
        wait(s);
        // 临界区
    	signal(s);
        // 剩余区
    }
}

PB(){
    while(1){
        wait(s);
        // 临界区
    	signal(s);
        // 剩余区
    }
}

main(){
	s=1;	//init
	// begin
    PA();
    PB();
    // end
}
```

前驱关系：P1，P2同步，P2→P1

```C++
CopyPA(){
    P(s);
    a1;
}

PB(){
    a2;
    V(s);
}
```

总结：

- **互斥**的模式：PV总是成对出现在**同一**进程中；
- **同步**的模式：PV总是成对出现在**不同**进程中；
- **前驱**关系：有多少前驱关系设置多少个信号量，初值为0；有多少前驱做多少P操作，有多少后继结点做多少V操作，无前驱不做P操作。

**信号量**表示的是**临界资源数**
初值为2，表示初始时有2个可用的资源，若现在为**-1**，说明这两个可用资源已经被占用了，而且有一个进程在等待资源
初值为3，表示初始时有3个可用的资源，若现在为**1**，表示有两个资源被进程访问了，可用资源变为**1**，没有进程会等待

为了使两个进程**同步**运行，至少**2**个信号量

#### 例题[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2822188152)

1.桌上有一空盘，允许**存放一只水果**，爸爸可向盘内放苹果或桔子，儿子专等吃**桔子**，女儿专等吃**苹果**

```C++
Copysemaphore s,so,sa=1,0,0;
father(){
    while(1) {
        wait(s);
        // 将水果放入盘中；
        if(放入的是桔子)
        then signal(so);
        else signal(sa);
    } 
}
son(){
	while(1){
    	wait(so);
        // 从盘中取出桔子
        signal(s);
        // 吃桔子
    }
}
daughter() {
    while(1){
        wait(sa);
        // 从盘中取出苹果
        signal(s);
        // 吃苹果
    }
}
main()
{
    // cobegin
    father();
    son();
    daughter();
    // coend
}
```

2.某寺庙，有小、老和尚若干，由小和尚提水入缸供老和尚饮用，水缸可容10桶水，水取自同一个井中，水井窄，每次只能容一个桶取水，水桶总数3个，每次入缸取水桶仅为1桶，且不可同时进行，试给出有关取水，入水的算法

```C++
Copymutexj = 1;
mutexg = 1;
empty = 10;
full = 0;
count = 3;

old(){
    while(1) {
        wait(full);		//缸中有无水
        wait(count);	//有无桶
        wait(mutexg);	//取水前
        Fetch from gang;
        signal(mutexg);
        signal(count);
        signal(empty);	//通知小
    }
}

little(){
	while(1) {
        wait(empty);	//缸中有无空
        wait(count);	//有无桶
        wait(mutexj);	//取水前
        Fetch from well;
        signal(mutexj);
        wait(mutexg);	//倒水前
        pour;
        signal(mutexg);
        signal(count);
        signal(full);	//通知老
    }
}
```

### 记录型信号量[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2827725114)

整形信号量中S<=0就会不断地测试，未遵循**让权等待**，而是处于**忙等**

解决方案：建立一个进程链表list，连结所有等待该类资源的进程

```C++
Copytypedef struct{
    int value;
    struct process_control_block *list
}semaphore;

wait(semaphore *S){
    S->value--;
    if(S->value < 0)
        block(S->list);
}

signal(semaphore *S){
    S->value--;
    if(S->value <= 0)
        wakeup(S->list);
}
```

1. S->value>0时，表示系统中**可用资源**的数目
2. 当S->value＜0时，S->value的绝对值表示**阻塞进程**的数目
3. 如果S->value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为**互斥信号量**

### AND信号量[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2890052449)

要么全分配，要么一个也不分配

不用时有可能发生死锁

```C++
CopySwait(s1,s2,…,sn){ 
    while(1){ 
        if (s1>=1& …&sn >=1){ 
            for(i=1;i<=n;i++) si--; 
            break;
        }
        else{
        	//将进程放入与找到的第一个si<1的si相关的阻塞队列中
			//并将该进程的程序计数设置为swait操作的开始
        }
	} 
}

Ssignal(s1,s2,…,sn){ 
    while(1){
        for (i=1;i<=n;i++){ 
            si++;
        	//将与si关联的队列中等待的所有进程都移动到就绪队列中
        } 
    } 
}
```

### 信号量集[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#542374246)

为提高效率而对AND信号量的扩充

允许一次申请多种资源多个

ti为分配下限值，Si>=ti则不分配，di为该进程需求值

```C++
CopySwait(S1, t1, d1, …, Sn, tn, dn){
	while(1){
        if（Si>=ti& … &Sn>=tn)
    		for (i=1;i<=n;i++) 
                Si=Si-di;
    	else{
            //将进程放在Si＜ti的第一个Si的阻塞队列中
            //并将该进程的程序计数设置为swait操作的开始	
    	}
    } 
} 

Ssignal(S1, d1, …, Sn, dn){
    while(1){ 
        for (i=1;i<=n;i++) {
            Si =Si+di;
        	//将与si关联的队列中等待的所有进程都移动到就绪队列中
        }
    }
}
```

Swait(S,d,d)：允许每次申请d个资源，少于d不分配

Swait(S,1,1)：S>1记录型信号量，S=1互斥形信号量

Swait(S,1,0)：可控开关，S>=1时允许同时进入，S<1时不允许

## 经典进程同步问题[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#843253694)

### 生产者-消费者*[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#753540273)

定义数据结构

```C++
Copyint n;
typedef item = xxx;	//产品类型
item buffer [n];	//缓冲池
int in = 0,out = 0;	
int counter = 0;	//产品数
```

缓冲池满时，生产者等待；为空时，消费者等待

**记录型信号量**

```C++
Copysemaphore mutex=1，empty=n,full=0
item buffer[n]; 	//缓冲池
int in = 0,out = 0;	

int main()
{
    cobegin:
    producer();
    consumer();
    coend
}

producer(){ 
	while(1){
        …
        produce an item in nextp; 
        …
        wait(empty);
        wait(mutex);
        buffer[in]=nextp;
        in=(in+1)%n;
        signal(mutex);
        signal(full);
    } 
}

consumer(){
	while(1) {
        wait(full);
        wait(mutex);
        nextc=buffer[out];
        out=(out+1)%n;
        signal(mutex);
        signal(empty);
        consumer the item in nextc;
    } 
}
```

**P操作的顺序至关重要**，顺序不当可能导致死锁（有缓冲池使用权，无缓冲）
V操作的顺序无关紧要
当缓冲区只有一个时，mutex可省略

**AND信号量**

```C++
Copysemaphore mutex=1,empty=n,full=0;
item buffer[n];
int in=0,out=0;
main(){
	cobegin
    producer();
    consumer();
    coend
}

producer()
{
    while(1)
    {
        ...
        produce......;
        ...
        Swait(empty,mutex);
        buffer[int]=nextp;
        in = (in+1)mod n;
        Ssignal(mutex,full);
    }
}

consumer(){
    while(1){
    	Swait(full,mutex);
        nextc=buffer[out];
        out=(out+1)%n;
        Ssignal(mutex,empty);
        consumer......;
    }
}
```

### 哲学家进餐[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#3637265004)

[![img](https://img2018.cnblogs.com/blog/1536438/201912/1536438-20191218000343115-851571421.png)](https://img2018.cnblogs.com/blog/1536438/201912/1536438-20191218000343115-851571421.png)

5个哲学家围坐，用5只筷子吃面，筷子交替摆放

**记录型信号量**

设5个信号量表示5只筷子

**AND信号量**

同上

### 读-写*[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#3305334490)

读进程可共享对象，写进程不可

设整形变量**readcount读者数**，**wmutex读写互斥**，rmutex互斥访问

记录型信号量：

```C++
Copysemaphore rmutex=1,wmutex=1;
int readcount=0;
int main(){
    cobegin:
    reader();
    writer();
    coend;
}

reader(){
    while(1){
        wait(rmutex);
        if(readcount==0) wait(wmutex);//无人读才能写
        readcount++;
        signal(rmutex);
        ...
        read......
        ...
        wait(rmutex);
        readcount--;
        if(readcount==0) signal(wmutex);
        signal(rmutex);
    }
}

writer(){
    while(1){
        wait(wmutex);
        ...
        write......
        ...
        signal(wmutex);
    }
}
```

写优先

```C++
Copysemaphore rmutex=1,wmutex=1,s=1;
int readcount=0;
int main(){
    cobegin:
    reader();
    writer();
    coend;
}

reader(){
    while(1){
        wait(s);//!
        wait(rmutex);
        if(readcount==0) wait(wmutex);//无人读
        readcount++;
        signal(rmutex);
        signal(s);//!
        ...
        read......
        ...
        wait(rmutex);
        readcount--;
        if(readcount==0) signal(wmutex);
        signal(rmutex);
    }
}

writer(){
    while(1){
        wait(s);//!
        wait(wmutex);
        ...
        write......
        ...
        signal(wmutex);
        signal(s);//!
    }
}
```

**信号量集**

```C++
Copy#define RN 20//最大读者数
semaphore L=RN，mx=1;

int main(){
    cobegin:
    reader();
    writer();
    coend;
}

reader(){
    while(1){
		swait(L,1,1);
        swait(mx,1,0);
        ...
        read......
        ...
        wait(rmutex);
        ssignal(L,1);
    }
}

writer(){
    while(1){
		swait(mx,1,1);
        swait(L,RN,0);
        ...
        write......
        ...
        ssignal(mx,1);
    }
}
```

## 管程[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#2340146253)

将同步操作的机制和临界资源结合到一起，避免了要使用临界资源的进程自备同步操作

管程：一个**数据结构**和**能为并发进程所执行的一组操作**
包括：1. 局部对于管程的**共享变量**，2. 对该数据结构操作的**一组过程**，3. 对局部管程数据设**初值**

[![img](https://img2018.cnblogs.com/blog/1536438/201912/1536438-20191218111312451-340675577.png)](https://img2018.cnblogs.com/blog/1536438/201912/1536438-20191218111312451-340675577.png)

```C++
CopyMonitor m_name{			//管程名
    variable declarations;	//共享变量说明
    cond declarations;		//条件变量说明
    public:					//能被进程调用的过程
    void P1(…);				//对数据结构的操作过程
    {}					
    void P2(…);				
    {}		
    ...
    void Pn(…);				
    {}
    ...
    {
		//管程主体
        //初始化代码
    }
}
```

### 生产者-消费者[#](https://www.cnblogs.com/zhxmdefj/p/12059174.html#1626927752)

建立管程PC，包括：

- 二过程：put(item)过程；get(item)过程；
- 一变量：count>=n时满，<=0时空
- 初始值：in=out=count=0

```C++
CopyMonitor PC{
    item buffer[N];
    int in out;
    condition notfull,notempty;
    int count;
    public:
    void put(item x){
        if(count>=N)cwait(notfull);
        buffer[in]=x;
        in=(in+1)%N;
        count++;
        csignal(notempty);
    }
    void get(item x){
        if(count<=0)cwait(notempty);
        x=buffer[out];
        out=(out+1)%N;
        count--;
        csignal(notfull);
    }
}

void producer(){
    item x;
    while(1){
        //produce
        PC.put(x);
    }
}

void consumer(){
    item x;
    while(1){
        PC.get(x);
        //consume
    }
}
```