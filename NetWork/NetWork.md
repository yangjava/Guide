## DNS

### DNS是什么

**官方解释**：DNS（Domain Name System，域名系统），因特网上作为**域名和IP地址相互映射**的一个**分布式数据库**，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。

**通俗的讲**，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。

### 谈谈DNS解析过程

![Net-DNS解析](png\Net-DNS解析.png)

- 请求一旦发起，若是chrome浏览器，先在浏览器找之前**有没有缓存过的域名所对应的ip地址**，有的话，直接跳过dns解析了，若是没有，就会**找硬盘的hosts文件**，看看有没有，有的话，直接找到hosts文件里面的ip

- 如果本地的hosts文件没有能的到对应的ip地址，浏览器会发出一个**dns请求到本地dns服务器**，**本地dns服务器一般都是你的网络接入服务器商提供**，比如中国电信，中国移动等。
- 查询你输入的网址的DNS请求到达本地DNS服务器之后，**本地DNS服务器会首先查询它的缓存记录**，如果缓存中有此条记录，就可以直接返回结果，此过程是**递归的方式进行查询**。如果没有，本地DNS服务器还要向**DNS根服务器**进行查询。
- 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
- 最后，本地DNS服务器向**域名的解析服务器**发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

### DNS查询方式

#### 递归解析

当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。**局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询**。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。

#### 迭代解析

当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，**而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序**，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。

### DNS负载均衡

当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在**DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器**,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。

### 为什么域名解析用UDP协议？

因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手。但是UDP协议传输内容不能超过512字节。不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。

### 为什么区域传送用TCP协议？

因为TCP协议可靠性好啊！你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？

#### 字节问了修改hosts，浏览器会变吗？

那么在修改hosts文件之后，发生了什么事情呢？这里不妨先提提Chrome下的一个工具：[chrome://net-internals/#dns](https://blog.csdn.net/woshizhangliang999/article/details/51457864)。这里列出了目前系统中的DNS缓存和Chrome中使用的情况。通过这个工具，可以看到： 在修改hosts文件后，所有OS中DNS缓存会被清空，而浏览器缓存则不发生变化。 网上盛传[chrome://net-internals/#dns](https://blog.csdn.net/woshizhangliang999/article/details/51457864)下的"Clear Host Cache"可以清空DNS缓存，这里博主做了一个测试，这里清空的仅仅是OS的缓存，而并非浏览器DNS缓存。当某条DNS记录显示"Expired"的时候，才表示浏览器DNS缓存已经被清除。所以使用Clear Host Cache其实是没有用的。

那么回到最初的问题上来，为什么修改hosts文件之后，有时会立刻生效，有时却一直不生效呢？其实原因很简单，这是因为浏览器缓存的过期时间，是从某个域名上次查询DNS记录开始计算的。

例如：我00秒的时候使用chrome访问过www.google.com.hk，此时浏览器DNS缓存产生，然后我修改了hosts文件，将www.google.com.hk指向本地127.0.0.1，然后在05秒的时候尝试再次访问这个地址，因为浏览器DNS缓存未过期，所以hosts修改无法体现出来。

另一种情况下，我很久都没有访问www.baidu.com了，然后我修改了hosts文件，将其指向127.0.0.1，这时因为浏览器没有DNS缓存，所以会查询操作系统中的DNS缓存，结果此时hosts文件生效！

前面也提到，Safari的浏览器DNS缓存时间大约为10秒，所以一般调试程序的时候，很多人都习惯修改hosts后，用Safari来调试，因为大部分情况下，修改hosts之后，浏览器DNS缓存已经失效了。

那么怎么主动清除浏览器DNS缓存呢？博主目前也没有找到办法，测试过Chrome下的“清除缓存”选项，发现没有起到期望的效果。

那么，就请在修改hosts之后，耐下心来，稍等几十秒吧。

## HTTP

### GET和POST的区别？

1. GET使用URL或Cookie传参，而POST将数据放在BODY中
2. GET方式提交的数据有长度限制，则POST的数据则可以非常大
3. POST比GET安全，因为数据在地址栏上不可见，没毛病
4. **本质区别**：GET请求是幂等性的，POST请求不是。

> 这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。

正因为它们有这样的区别，所以不应该且**不能用get请求做数据的增删改这些有副作用的操作**。因为get请求是幂等的，**在网络不好的隧道中会尝试重试**。如果用get请求增数据，会有**重复操作**的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。

### 响应码

#### 1xx 信息

**100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

#### 2xx 成功

- **200 OK**
- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

#### 3xx 重定向

- **301 Moved Permanently** ：永久性重定向
- **302 Found** ：临时性重定向
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

#### 4xx 客户端错误

- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被拒绝。没有权限
- **404 Not Found**：路由不存在，或者没找到

#### 5xx 服务器错误

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。


### HTTP首部

> 这块有点多，可参考[http首部](https://github.com/DreamCats/JavaBooks/blob/master/Interview/network/计算机网络原理-http那些事儿.md#http首部)

### Cookies

HTTP 协议是**无状态**的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie 是**服务器发送到用户浏览器并保存在本地的一小块数据**，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）


### Session

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

### Cookie和Session的选择

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

### JWT

JWT(json web token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。

cookie+session这种模式通常是保存在**内存**中，而且服务从单服务到多服务会面临的session共享问题，随着用户量的增多，开销就会越大。而JWT不是这样的，**只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可**。

**JWT的构成**：

第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)。详情请见[官网](https://jwt.io/introduction/)

**JWT总结**：

1. 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。
2. payload部分，JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
3. 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。它不需要在服务端保存会话信息, 所以它易于应用的扩展。

[jwt优缺点](https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT-advantages-and-disadvantages)

### 浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，**某些服务器对 Connection: keep-alive 的 Header 进行了支持**。

**持久连接**：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。


### 一个TCP连接可以对应几个HTTP请求？

如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。

### 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？

HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。

在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。

那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：

- 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。
- 和服务器建立多个 TCP 连接。

### 为什么有的时候刷新页面不需要重新建立 SSL 连接？

TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。

### 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？

**有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。**


### 在浏览器中输入url地址后显示主页的过程?

> - 根据域名，进行DNS域名解析；
> - 拿到解析的IP地址，建立TCP连接；
> - 向IP地址，发送HTTP请求；
> - 服务器处理请求；
> - 返回响应结果；
> - 关闭TCP连接；
> - 浏览器解析HTML；
> - 浏览器布局渲染；


### HTTP1.x的缺点

1. HTTP/1.0 一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求分析，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟
2. 单向请求，只能由客户端发起
3. 请求报文与响应报文首部信息冗余量大。
4. 数据未压缩，导致数据的传输量大。

### HTTP2.0有哪些改动

1. 多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
2. 二进制分帧：应用层（HTTP/2）和传输层（TCP or UDP）之间增加一个二进制分帧层。
3. 首部压缩（Header Compression）
4. 服务端推送（Server Push）


## HTTPS

### HTTPS是什么

HTTPS 并不是新协议，而是让 **HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信**。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

### HTTP的缺点

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

### 对称密钥加密

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

- 优点：运算速度快
- 缺点：无法安全地将密钥传输给通信方

### 非对称密钥加密

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。

公开密钥所有人都可以获得，**通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密**，**接收方收到通信内容后使用私有密钥解密**。

非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。

### HTTPS采用的加密方式

HTTPS 采用混合的加密机制，使用**非对称密钥加密用于传输对称密钥来保证传输过程的安全性**，之后使用**对称密钥加密进行通信来保证通信过程的效率**。DES+RSA

![rsa原理-rWg4oK](https://gitee.com/dreamcater/blog-img/raw/master/uPic/rsa原理-rWg4oK.png)

确保传输安全过程（其实就是rsa原理）：

1. Client给出**协议版本号**、一个客户端生成的**随机数**（Client random），以及客户端支持的**加密方法**。
2. Server确认双方使用的**加密方法**，并给出**数字证书**、以及一个服务器生成的**随机数**（Server random）。
3. Client确认**数字证书有效**，然后生成一个新的**随机数**（Premaster secret），并使用**数字证书中的公钥，加密这个随机数**，发给Server。
4. Server使用自己的**私钥，获取Client发来的随机数**（Premaster secret）。
5. Client和Server根据约定的加密方法，使用前面的**三个随机数，生成”对话密钥”**（session key），用来加密接下来的整个对话过程。

### 认证

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

[加密全套流程](https://www.cnblogs.com/handsomeBoys/p/6556336.html)

[https://www.cnblogs.com/xdyixia/p/11610102.html](https://www.cnblogs.com/xdyixia/p/11610102.html)

### HTTPS的缺点

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

# 关于分层

我们使用四层模型更为贴合我们的实际网络。应用层，传输层，网络层，网络接入层。

分层是为什么，其实和公司中职位是一样的，不同职位的人做不同的事情，然后不同职位的人合起来，一起完成了数据传输的事情。

## 网络传输层

网络传输层负责最底层的底层链路连接。两台主机之间进行互联，基于网线的物理硬件上的协议。在这个层面，主机与主机的交互只认得硬件mac编号，并不认识IP。这个层需要了解的一个概念是MTU，网络中每个路由都会设置一个MTU，代表这个路由中能通过的最大的包的大小。那么整个网络链路的MTU值就是由网络中所有路由的最小MTU决定。这个就好比水路管道，水流量是由管道链路中管子最小的那个链路来决定的。

## 网络层

IP的出现是很有必要的，就像给网络上每个机器一个门牌号，网络层，你可以把它理解为邮件运输工，它的职能就是负责把一包东西，从这个门牌运输到另外一个门牌。

## 传输层

传输层相比于网络层最大的不同就是引入了端口的概念。网络层只管发送地址和目的地址。但是发送主机上有可能有多个程序和同一个接收主机进行传输数据，怎么区分这多个程序呢？就引入了端口的概念。（发送IP地址，发送端口，接收IP地址，接收端口）四元组标示了一个主机的程序到另一个主机程序的唯一标示。传输层的职能，就是维护这个四元组。

其实传输层还有一个职能是定义发送方和接收方基本处理包的行为。上面说到网络层就相当于邮件运输工，它只负责把一包东西从一个地方放到另外一个地方，但是，这包东西是否送达了，送达之后接收方又有什么行为。这些都可以在传输层进行定义。注意，这里说的是可以，你也可以在传输层布不管这些，只做简单的基本封装四元组。你懂的，我说的就是UDP。

## 应用层

应用层，就更抽象一层了。我们这个端口和那个端口的连接是用来干什么的，传输文件？那么可以使用FTP。传输文本？那么可以使用HTTP。应用层就是实际上对具体的程序之间的交互功能进行定义的层。

如果你比较钻牛角尖的话，可能会提出的问题是：为什么要分为四层？为什么不是分为两层，五层？

这里分为几个问题解释：

## 为什么要分层？

分层实际上是一个抽象的过程，和我们写代码的时候的封装是一样的。你要说，我只有一层，一个协议把所有从程序到物理网络的所有东西都描述一遍，这个可以不可以？可以。但是，这样你协议写多了以后，就会发现，物理网络部分几乎所有协议都一样，那么我倒不如另外写一个协议，然后其他协议使用include的方式来包含这个协议。好了，网络传输层就出来了。后面的原理也几乎一样了。所以分层是必要的。

## 为什么分为四层？

代码中有个过度设计的概念，分层中也照样有个过度设计的概念。基本上，分层层数越多，是越符合抽象的。但是到最后我们会发现，有一个协议整篇都是include，自己实际上并没有任何实质的东西。这个就是过度设计。基本上我们琢磨来琢磨去，按照上面说的，分为四层，是个很合适的设计。四层中的每一层都有自己负责的一块内容，内容大小适中，又没有相互耦合的地方。四层中的每一层都不可缺少。

## TCP/UDP

## TCP协议

TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

### TCP头格式

![Net-TCP头格式](png\Net-TCP头格式.png)

  你需要注意这么几点：

- TCP的包是没有IP地址的，那是IP层上的事，但是有源端口和目标端口。
- 一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。
- 注意上图中的四个非常重要的东西：
  - **Sequence Number**是包的序号，**用来解决网络包乱序（reordering）问题。**
  - **Acknowledgement Number**就是ACK——用于确认收到，**用来解决不丢包的问题**。
  - **Window又叫Advertised-Window**，也就是著名的滑动窗口（Sliding Window），**用于解决流控的**。
  - **TCP Flag** ，也就是包的类型，**主要是用于操控TCP的状态机的**。

#### **Source Port(源端口)、Destination Port(目的端口)**

各占2个字节，这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。有时一个IP地址和一个端口号也称为socket。

#### Sequence Number(**序号**)

称为「序列号」。用于 TCP 通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信的有序性，避免网络中乱序的问题。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。初始序列号由自己定，而后绪的序列号由对端的 ACK 决定：SN_x = ACK_y (x 的序列号 = y 发给 x 的 ACK)。

占4个字节，是本报文段所发送的数据项目组第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。例如，一报文段的序号为300，而且数据共100字节，则下一个报文段的序号就是400；序号是32bit的无符号数，序号到达2^32-1后从0开始。

#### Acknowledgment Number(**确认序号**)

称为「确认序列号」。确认序列号是接收确认端所期望收到的下一序列号。确认序号应当是上次已成功收到数据字节序号加1，只有当标志位中的 ACK 标志为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题。

##### 问题

首先第一个问题，序列号做什么用呢？

序列号是用来标记包的顺序的，假设有一段要传输的内容大小有9000字节，按照1460字节一个包的大小，假设初始序号为10000，那么我们就把这段内容分为10000-11460， 11460-12920，... 18760-19000 一共7个包。网络包由于网络问题，可能并不是顺序到达接收端的，那么接收端可以按照序列号来重新组装这段内容。

第二个问题，序列号有两个说明什么？

说明tcp是全双工的，就是说，tcp的任意一端可以发送数据，也可以接收数据。那么需要有个发送序列号seqence Number和接收序列号 Acknowledgement Number。

#### Data offset(数据偏移)

   占4比特，表示数据开始的地方离TCP段的起始处有多远。实际上就是TCP段首部的长度。由于首部长度不固定，因此数据偏移字段是必要的。数据偏移以32位为长度单位，

也就是4个字节，因此TCP首部的最大长度是60个字节。即偏移最大为15个长度单位=1532位=154字节。

#### Reserved(**保留**)

6比特，供以后应用，现在置为0。

#### Tag(**6个标志位比特**)

① URG：当URG=1时，注解此报文应尽快传送，而不要按本来的列队次序来传送。与“紧急指针”字段共同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长。RFC已经建议废弃

② ACK：说明这个包中带有回复信息。只有当ACK=1时，确认序号字段才有效；

③ PSH：说明这个包中有传输数据。当PSH=1时，接收方应该尽快将本报文段立即传送给其应用层。

④ RST：重置位，说明这个包是用来要对方重置连接。当RST=1时，表示出现连接错误，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接。

⑤ SYN：建立连接，说明发送方向另一方发送建立连接的请求。SYN=1,ACK=0时表示请求建立一个连接，携带SYN标志的TCP报文段为同步报文段。

⑥ FIN：发端完成发送任务。结束位，说明发送一方告知另外一方，要请求中断连接

熟悉这些Tag位是非常必要的，我们一般讨论包请求的时候，使用的术语一般就是：
发送方请求一个SYN，接收方返回一个ACK。每每看到这种字眼，请不要傻眼。

还有一个误区，一个包是不是只能包含一个tag位？不是的。一个包可以包含一个或者多个tag位。比如一个包可以有ACK的功能，也能同时有SYN的请求功能。（在TCP三次握手的第二次握手的时候就是携带了ACK+SYN的标志位）。

#### Window(**窗口**)

这个值就是著名的滑动窗口值。滑动窗口是接收端告诉发送端下次可以发送多少包。好吧，这里也需要面对几个问题：

##### 避免误区：发送方和接受方的请求－响应并不是一一对应的。

网络上并不是只有发送方发一个请求，接收方回复一个ACK这种模式的。他们交互的模式更可能是：发送方一次发送多个请求包，接收方回复一个ACK，把这些请求包都回复了。这个使用前面的Acknowledgment Number是可以做到的。

但是基本上，在接收方的角度，ACK包一定是收到一个包之后，才返回一个ACK，就是说，没有无缘无故的发送重复ACK，没有一个请求，多个ACK这种情况。但是有多个请求，多个重复ACK的情况，这个时候，往往说明某个请求的包丢失了。

##### 为什么需要有滑动窗口存在？

滑动窗口的存在是为了控制网络上包的数量。如果没有滑动窗口，那么就是一个很理想很理想的情况，发送方一有数据，加上包头达到MTU大小，直接发送，就和冲锋枪一样，突突突突。但是呢？这样子，实际上，没有考虑到接收方是否能接收完。接收端就像一个一直在吃饭的胖子，他的吃饭速度是固定的，它一次性最多能吃10碗饭，某个时刻可能已经吃了两碗饭，但是还没消化。所以这个时候，它只能再吃8碗饭了，如果这个时候你一下子给它80碗，必然导致它堵死了，吃不下不吃下。这个滑动窗口就是接收端告诉发送端我还能吃几碗饭的通话器。

总结下，这里已经有两个条件限制发送方的效率了，一个是MTU，全链路MTU大小，限制每次最大发送的包的大小。另一个是滑动窗口，限制发送方一次发送的包数量。

##### 为什么叫滑动窗口？

滑动窗口我更愿意理解为发送方和接收方共同维护的。分别有发送窗口和接收窗口区别。

![img](https://images2015.cnblogs.com/blog/136188/201609/136188-20160926140625875-1057976235.png)

发送方数据有几个状态：数据已发送未收到ACK，数据已发送收到ACK
接收方数据有几个状态：数据已收到未被应用层消费，数据已收到已被应用层消费

把发送数据横拍做长列状，发送方一但有数据收到ACK，那么滑动窗口左侧边就进行左移。同样，一旦接收方有数据被应用层消费，那么，滑动窗口的右侧边就进行右移。整个过程，就好比努力爬行的蚯蚓，尾巴向前挪一寸，头部再向前走一寸，直到把整个数据都从头到尾移动完毕。

回到tcp的windows字段，这个字段是接收端回复给发送端，告诉发送端接收端的窗口大小的。我们其实默认也把这个窗口大小叫做滑动窗口大小。

关于滑动窗口的概念的理解，我的感触是网上各种各样对这个滑动窗口的描述，不要陷入到咬文嚼字中，头脑中形象有这个滑动窗口的滑动过程，就可以了，很多文章很多描述可能是前后矛盾的。比如，下面两个关于发送窗口的描述：

- 发送窗口是由滑动窗口和拥塞窗口共同决定的。
- 发送窗口是由接收窗口决定的。

#### CheckSum(**检验和**)

校验和。就是对TCP的头部和数据部分进行检验，是否在中途被篡改过。它和IP头中的校验和的算法是一样的，只是IP校验内容中不包括数据，但是TCP是包括头部和数据两个部分的。

#### Urgent Pointer(**紧急指针**)

紧急数据指针。紧急数据指的是发送端告诉接收端，这个数据是非常紧急的，请优先读取，设计初期可能是由于考虑到中断或者异常等情况，但是在RFC6093中已经明确，紧急数据已经是废弃功能了。不建议使用。只为旧程序兼容而使用。

所以，对于Urgent Porinter和tag中的URG标示就不要使用了。

#### Options (扩展)

options字段相当于扩展使用的，RFC有哪些信息要传输，而头部没有安排的字段，就可以放在options中进行传输。

####  padding(对齐)

padding是为了对其字节位。

### 握手连接

一个最常遇到的月经鸡汤面试题就是，UDP和TCP有什么不同。嗯，猴子和老虎就是不一样的。经常我们会提及的一点就是TCP是可靠的，UDP是不可靠的。TCP的可靠体现在哪里呢？握手连接的建立和消失就是其中一个体现。

TCP著名的三次握手和四次挥手

![Net-TCP三次握手四次挥手](png\Net-TCP三次握手四次挥手.png)

这个图里面的client和server应该理解为发送方和接收方。下面这一串描述请熟练练习到像串口相声一样：发送方发送一个SYN到接收方请求建立连接，接收方返回一个ACK确认收到请求，并携带一个SYN给发送方请求建立双向连接，发送方再返回一个ACK给接收方确认，这个时候连接就建立了。

顺势说下四次挥手吧。发送方发送一个FIN给接收方主动请求断开连接，接收方返回一个ACK确认，接着接收方再发送一个FIN请求断开另一方向的连接，发送方收到之后返回一个ACK确认。这个时候，连接就中断了。

在三次握手和四次挥手的时候，发送方和接收方的socket是有状态的，对，就是你使用netstat 能看到机器上socket的状态。
SYN_SENT/SYN_RCVD/ESTABLISH/FIN_WAIT1/CLOSE_WAIT/FIN_WAIT2/LAST_ACK/TIME_WAIT



很多人会问，为什么建立链接要3次握手，断开链接需要4次挥手？

- **对于建立链接的3次握手，**主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。

- **对于4次挥手，**其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。

# 拥塞阻塞

TCP不是一个自私的协议，它的设计充分考虑了互联网的大环境。试想，如果所有的网络发送方都不管网络的情况，明明网络已经堵塞了，还一个劲地发送大量包，甚至重发，那么这个时候，大家都没得玩了。于是，渐渐的，TCP引入了拥塞窗口（cwnd）的概念。拥塞窗口的存在单纯是为了避免网络上有超过当前网络能力而造成堵塞。拥塞窗口的单位是报文段个数。比如我们平时会说，现在的拥塞窗口为3，代表发送端可以一次性发送3个报文段。当然，实际上，发送端的最大发送窗口数取决于拥塞窗口（cwnd）和滑动窗口（win）的最小值。

控制网络拥塞的算法为拥塞算法，这个算法在不断演变，在不同操作系统中也有不同实现。

## 慢启动

控制拥塞我们首先会想到在刚刚连接网络的时候，是不是最好先慢慢检测网络情况，再确定发送包的数量。这就是我们说的慢启动算法。发送方从1个包开始，收到ACK，下次就发送2个包，收到这两个包的ACK（请注意，这里有可能只有一个ACK），下次就发送4个包。

“每收到一个ACK，拥塞窗口就增加一个报文段”。

这句话我更愿意理解为“每确认一个包被ACK了，拥塞窗口就增加一个报文段”

这句话的理解就是，由于有“延迟ACK”算法，很有可能，当发送方发送两个请求包过来的时候，我只发送一个ACK。确认你发送的两个包，这个时候，cwnd实际上是加2，而不是加1。如下图中的cwnd为4的ACK。

![img](https://images2015.cnblogs.com/blog/136188/201609/136188-20160926140834360-936190198.png)

当然上图的情况太理想，实际的情况，坑cwnd为2的请求发出去两个报文包的时候，先返回了一个ACK，然后cwnd这个时候就为3，发送方就会继续发送请求包。。。更贴近实际的正如这个图：

![img](https://images2015.cnblogs.com/blog/136188/201609/136188-20160926140854438-1828501677.png)

## 拥塞避免算法

慢启动使得cwnd是呈指数增长。一定不可能是无限增长的，这里就有个阀值，超过这个阀值，就进入拥塞避免算法。

先说拥塞避免算法，拥塞避免算法说的是拥塞窗口的增加不再是“每收到一个ACK，拥塞窗口就增加一个报文段”。 而是“每收到一个ACK，cwnd = cwnd + 1/cwnd”。 这个就代表，

![img](https://images2015.cnblogs.com/blog/136188/201609/136188-20160926140915594-1003392395.png)

## 判断拥塞

我们怎么判断拥塞呢？有两种判断方法：

a 超时重传（发出去的包在指定时间内没有收到ACK）

这个指定时间是通过超时定时器来计算的，发出去一个包，超时定时器就开始计时，当超时定时器到时间之后，没有收到ACK，那么这个时候就判断为拥堵了。需要进行重传。

![img](https://images2015.cnblogs.com/blog/136188/201609/136188-20160926140951203-145085735.png)

当被这个情况触发，TCP认为网络情况非常糟糕，所以会直接把cwnd调整为1，sshthread 调整为cwnd/2 。 重新进入到慢启动流程。

b 快速重传（重复收到ACK）

这个是由于发送方一次性发送多个请求（比如5个请求，但是第二个请求丢失了，第一三四五请求到了接收端）三四五请求触发了三个ACK返回，但是由于接收端没有收到请求一，返回的三个ACK都是ACK一的，所以发送方就表现为收到重复ACK。当连续收到三条重复ACK的时候就进行重传，不需要等待重传计时器

![img](https://images2015.cnblogs.com/blog/136188/201609/136188-20160926141013953-120441263.png)

这个时候TCP会觉得网络还是可以的，反应不会那么激烈，cwnd调整为cwnd/2, sshthresh调整为cwnd大小，进入快速恢复算法。

## 快速恢复算法

快速恢复算法是为了不要有一个重传就那么大响应。能尽快恢复到网络流畅时候稳定的状态。

- cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）
- 重传Duplicated ACKs指定的数据包
- 如果再收到 duplicated Acks，那么cwnd = cwnd +1
- 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。

# 定时器

TCP中有四个定时器，有的定时器之前已经说过了。

## 重传定时器

是为了重传的时候使用的。

## 2MSL定时器

在上面说到TCP挥手的时候，四次挥手中最后一次挥手，主动发起的一方会进入TIME_WAIT状态2MSL的时常，这个定时器就是用来计算这个的。

## 坚持定时器

当滑动窗口为0的时候，发送方不会再发送包给接收方了。但是不发送包怎么知道接收方现在的窗口是不是还为0呢。这个时候就需要不定时去接收方咨询是否滑动窗口还为0。这个不定时的算法就是使用坚持定时器来进行咨询的。

这个算法是使用TCP指数退避方法，第一次1.5秒，第二次1.5x2秒，第三次1.5x4... 以此规律来进行轮询的。

## 保活定时器

tcp有个keepalive机制，这个只有在一定时间内（tcp_keepalive_time，默认每2个小时），没有数据包传递了，发送方在发送心跳检测，如果发送成功，则连接继续，如果没有正常返回，则在指定次数内（tcp_keepalive_probes，默认是9次），指定间隔（tcp_keepalive_intvl，默认是17s）发送心跳包。

# 名词回顾

- 滑动窗口
- 阻塞窗口
- MTU
- MSS
- MSL
- 重传定时器
- 2MSL定时器
- 坚持定时器
- 保活定时器
- 慢启动
- 拥塞避免算法
- 快速恢复算法
- 快速重传算法
- backlog
- 三次握手
- 四次挥手

# 后记

tcp的东西真是比较复杂。好吧，这玩意根本没法讲通俗。我的理解或许有偏差，如果有错误，希望能帮忙留言提出。同时，强烈建议，看完这篇再看一遍耗子哥的《TCP的那些事儿》(http://coolshell.cn/articles/11564.html)。或许还能回来告诉下我哪些地方我理解有问题。

### TCP三次握手

![TCP三次握手-2ujCx2](https://gitee.com/dreamcater/blog-img/raw/master/uPic/TCP三次握手-2ujCx2.svg)

- **初始状态**：客户端处于 `closed(关闭)`状态，服务器处于 `listen(监听)` 状态。
- **第一次握手**：客户端发送请求报文将 `SYN = 1`同步序列号和初始化序列号`seq = x`发送给服务端，发送完之后客户端处于`SYN_Send`状态。
- **第二次握手**：服务端收到 `SYN` 请求报文之后，如果同意连接，会以自己的同步序列号`SYN(服务端) = 1`、初始化序列号 `seq = y`和确认序列号（期望下次收到的数据包）`ack = x + 1` 以及确认号`ACK = 1`报文作为应答，服务器为`SYN_Receive`状态。（问题来了，两次握手之后，所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）
- **第三次握手**： 客户端接收到服务端的 `SYN + ACK`之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 `ack = y + 1`和数据包的序列号 `seq = x + 1`以及确认号`ACK = 1`确认包作为应答，客户端转为`established`状态。（分别站在双方的角度上思考，各自ok）

1. 你吃饭了嘛？（seq=x），收到请回答（SYN=1）
2. 收到（ACK=1），吃饭了（ack=x+1），你吃饭了吗？（seq=y），收到请回答（SYN=1）
3. 收到（ACK=1），吃饭了（ack=y+1），那么我们聊一下接下里的事情（established）

### TCP四次分手

![TCP四次分手-Nt8NUx](https://gitee.com/dreamcater/blog-img/raw/master/uPic/TCP四次分手-Nt8NUx.png)

- **初始化状态**：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。
- **第一次分手**：第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。

> 假如客户端发送的数据已经发送完毕，发送FIN = 1 **告诉服务端，客户端所有数据已经全发完了**，**服务端你可以关闭接收了**，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN = 1等待服务端确认释放连接状态。

- **第二次分手**：服务端接收到客户端的释放请求连接之后，**知道客户端没有数据要发给自己了**，**然后服务端发送ACK = 1告诉客户端收到你发给我的信息**，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）
- **第三次分手**：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN = 1，**用于告诉客户端，服务端的所有数据发送完毕**，**客户端你也可以关闭接收数据连接了**。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢）
- **第四次分手**：此时如果客户端收到了服务端发送完的信息之后，就发送ACK = 1，告诉服务端，客户端已经收到了你的信息。**有一个 2 MSL 的延迟等待**。

#### 为什么要有2MSL等待延迟？

对应这样一种情况，最后客户端发送的ACK = 1给服务端的**过程中丢失**了，服务端没收到，服务端怎么认为的？我已经发送完数据了，怎么客户端没回应我？是不是中途丢失了？然后服务端再次发起断开连接的请求，一个来回就是2MSL。

客户端给服务端发送的ACK = 1丢失，**服务端等待 1MSL没收到**，**然后重新发送消息需要1MSL**。如果再次接收到服务端的消息，则**重启2MSL计时器**，**发送确认请求**。客户端只需等待2MSL，如果没有再次收到服务端的消息，就说明服务端已经接收到自己确认消息；此时双方都关闭的连接，TCP 四次分手完毕

#### 为什么四次分手？

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

### TCP粘包

**TCP粘包**是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。


个人觉得：应用层的报文在以流的形式传输时，每一个报文的报头紧接着上一个报文的报文尾部，这就是所谓的“粘包”问题。

- 由TCP**连接复用**造成的粘包问题。
- 因为TCP默认会使用**Nagle算法**，此算法会导致粘包问题。
  - 只有上一个分组得到确认，才会发送下一个分组；
  - 收集多个小分组，在一个确认到来时一起发送。
- **数据包过大**造成的粘包问题。
- 流量控制，**拥塞控制**也可能导致粘包。
- **接收方不及时接收缓冲区的包，造成多个包接收**

**解决**：

1. **Nagle算法**问题导致的，需要结合应用场景适当关闭该算法
2. 尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。
3. 头部标记分步接收。在TCP报文的头部加上表示数据长度。
4. 应用层发送数据时**定长**发送。

[https://blog.csdn.net/xp178171640/article/details/104746379/](https://blog.csdn.net/xp178171640/article/details/104746379/)

[https://blog.csdn.net/songchuwang1868/article/details/87707127](https://blog.csdn.net/songchuwang1868/article/details/87707127)

### TCP 协议如何保证可靠传输？

- **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- **数据校验**：TCP报文头有校验和，用于校验报文是否损坏。
- **数据合理分片和排序**：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。
- **流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- **拥塞控制**：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

### TCP 利用滑动窗口实现流量控制的机制？

>  流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着**接收方还有多大的缓冲区可以用于接收数据**。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。

> 例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

### TCP拥塞控制的机制以及算法？

> 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

TCP 发送方要维持一个 **拥塞窗口(cwnd) 的状态变量**。拥塞控制窗口的大小**取决于网络的拥塞程度**，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

### TCP的长连接和短连接

[https://www.cnblogs.com/chinaops/p/9303041.html](https://www.cnblogs.com/chinaops/p/9303041.html)

### UDP

提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

#### UDP的特点

- UDP是**无连接的**；
- UDP使用**尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
- UDP是**面向报文**的；
- UDP**没有拥塞控制**，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；
- UDP**支持一对一、一对多、多对一和多对多**的交互通信；
- UDP的**首部开销小**，只有8个字节，比TCP的20个字节的首部要短。

那么，再说一次TCP的特点：

- **TCP是面向连接的**。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
- 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（**一对一**）；
- TCP**提供可靠交付的服务**。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
- TCP**提供全双工通信**。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
- **面向字节流**。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

## 网络模型

![分层模型-EiHhGW](https://gitee.com/dreamcater/blog-img/raw/master/uPic/分层模型-EiHhGW.png)

### 简要概括

- 物理层：底层数据传输，如网线；网卡标准。 

- 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。

- 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。

- 传输层：端到端传输数据的基本功能；如 TCP、UDP。

- 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。

- 标识层：数据格式标识，基本压缩加密功能。

- 应用层：各种应用软件，包括 Web 应用。

### 流程

比如，计算机 A 和 计算机 B 要进行信息交互，比如 A 上开发了一个网页，需要 B 去访问。B 发出一个请求给 A，那么请求数据从 B 的 **应用层开始向下传到表示层、再从表示层传到会话层直到物理层，通过物理层传递到 A，A 的物理层接到请求后将请求向上传递到自己的应用层，应用层再将要请求的数据向自己的物理层方向传递然后 B 接到数据传递数据到自己的应用层**。

说明：

- 在四层，既传输层数据被称作**段**（Segments）；
- 三层网络层数据被称做**包**（Packages）；
- 二层数据链路层时数据被称为**帧**（Frames）；
- 一层物理层时数据被称为**比特流**（Bits）。

### 常见的端口号和协议号

![常见端口号-PemUq1](https://gitee.com/dreamcater/blog-img/raw/master/uPic/常见端口号-PemUq1.png)

### 总结

- 网络七层模型是一个标准，而非实现。
- 网络四层模型是一个实现的应用模型。
- 网络四层模型由七层模型简化合并而来。

### ping命令基于哪一层协议的原理是什么？

ping命令基于网络层的命令，是基于ICMP协议工作的。

### ARP

ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。
起初要通过广播发送一个ARP请求包，这个包里存放了其MAC地址的主机IP地址，由于广播的包可以被同一个链路上所有的主机或路由器接收，因此ARP的请求包也就会被这同一个链路上所有的主机和路由器进行解析。如果ARP请求包中的目标IP地址与自己的IP地址的一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。