# 订单支付

## 系统设计

### 业务关系

订单系统与各业务系统的关系：

![订单系统](F:/work/openGuide/Architecture/images/Architecture/订单系统.jpg)

- **对外系统**

  所有给企业外部用户使用的系统都在这一层，包括官网、普通用户使用的C端，还包括给商户使用的商家后台和在各个销售渠道进行分销的系统，比如与银行信用卡中心合作、微信合作在合作商的平台露出本企业的产品。这类系统站在与客户接触的最前线，是公司实现商业模式的桥头堡。

- **管理中后台**

  每个C端的业务形态都会有一个对应的系统模块，如负责管理平台交易的订单系统，管理优惠信息的促销系统，管理平台所有产品的产品系统，以及管理所有对外系统显示内容的内容系统等。

- **公共服务系统**

  随着企业的发展，信息化建设到达一定程度后，企业需要将通用功能服务化、平台化，以保证应用架构的合理性，提升服务效率。这类系统主要给其他应用系统提供基础服务能力支持。



### 上下游关系

![订单上下游关系](F:/work/openGuide/Architecture/images/Architecture/订单上下游关系.jpg)

由此可见，订单系统对上接收用户信息，将用户信息转化为产品订单，同时管理并跟踪订单信息和数据，承载了公司整个交易线的重要对客环节。对下则衔接产品系统、促销系统、仓储系统、会员系统、支付系统等，对整个电商平台起着承上启下的作用。



### 业务架构

![订单业务架构](F:/work/openGuide/Architecture/images/Architecture/订单业务架构.jpg)

- **订单服务**

  该模块的主要功能是用户日常使用的服务和页面，主要有订单列表、订单详情、在线下单等，还包括为公共业务模块提供的多维度订单数据服务。

- **订单逻辑**

  订单系统的核心，起着至关重要的作用，在订单系统负责管理订单创建、订单支付、订单生产、订单确认、订单完成、取消订单等订单流程。还涉及到复杂的订单状态规则、订单金额计算规则以及增减库存规则等。在4节核心功能设计中会重点来说。

- **底层服务**

  信息化建设达到一定程度的企业，一般会将公司公共服务模块化，比如：产品，会构建对应的产品系统，代码、数据库，接口等相对独立。但是，这也带来了一个问题，比如：订单创建的场景下需要获取的信息分散在各个系统。

  如果需要从各个公共服务系统调用：一是会花费大量时间，二是代码的维护成本非常高。因此，订单系统接入所需的公共服务模块接口，在订单系统即可完成对接公共系统的服务。



## 流程设计

### 订单流程

订单流程主要是订单产生到交易结束的整个流程，按照现在电子商城（E-mall），仓库管理（WMS），物流管理系统（TMS）的流转过程主要如下图：

![订单流程](F:/work/openGuide/Architecture/images/Architecture/订单流程.png)



### 正向流程

**订单创建>订单支付>订单生产>订单确认>订单完成**



### 逆向流程

![订单逆向流程](F:/work/openGuide/Architecture/images/Architecture/订单逆向流程.jpg)

上面说到逆向流程是各种修改订单、取消订单、退款、退货等操作，需要梳理清楚这些流程与正向流程的关系，才能理清订单系统完整的订单流程。

- **订单修改**：可梳理订单内信息，根据信息关联程度及业务诉求，设定订单的可修改范围是什么，比如：客户下单后，想修改收货人地址及电话。此时只需对相应数据进行更新即可。

- **订单取消**：用户提交订单后没有进行支付操作，此时用户原则上属于取消订单，因为还未付款，则比较简单，只需要将原本提交订单时扣减的库存补回，促销优惠中使用的优惠券，权益等视平台规则，进行相应补回。

- **退款**：用户支付成功后，客户发出退款的诉求后，需商户进行退款审核，双方达成一致后，系统应以退款单的形式完成退款，关联原订单数据。因商品无变化，所以不需考虑与库存系统的交互，仅需考虑促销系统及支付系统交互即可。

- **退货**：用户支付成功后，客户发出退货的诉求后，需商户进行退款审核，双方达成一致后，需对库存系统进行补回，支付系统、促销系统以退款单形式完成退款。最后，在退款/退货流程中，需结合平台业务场景，考虑优惠分摊的逻辑，在发生退款/退货时，优惠该如何退回的处理规则和流程。



## 关键设计

### 订单信息

![订单详细信息](F:/work/openGuide/Architecture/images/Architecture/订单详细信息.png)



### 订单单号

订单单号是订单信息中的主Key，代表了该订单的唯一性，并且使用在仓库管理系统中，WMS作为拆分合并订单中与电子商城中的订单关联的Key值。订单单号一般组成方式有以下两种：

- **日期时间+随机数字**
  - 初期业务量不多的时候20-26位足够应付
  - **yyyyMMddHHmmss（年月日时分秒） + 6位随机码**
  - 6位随机码表示一秒钟可能生成的订单数上，存在一百万分之一的随机并发相同导致下单失败，因此在初期业务每秒下单量不高的时候选择这种简单的方法足够满足需求

- **日期时间+自增**
  - 不会产生随机数生成冲突
  - 注意防治被查看到销售量需要将数字加密设置



### 倒计时时间

订单里面显示倒计时有：

- **下单未支付**

  - 商品下单后开始倒计时，一定时间内如果还未下单则超时关闭订单
  - 普通商品一般采取3天时间，特价商品根据情况一般采取的是30分钟，快消品一般采用的15分钟

- **已发货确认收货倒计时**

  商品一般是发货开始后开始倒计时10天时间，O2O商品应该是送达即收货。

  - 满1天记录1天 XX天hh小时mm分钟
  - 小于1天小时则hh小时mm分钟ss秒

  防止发货时间过长，发货后用户可以采用一次延长收货，商家/平台端则可以多次**延长收货**。



### 扣减库存

用户下单后，系统需要生成订单，此时需要先获取下单中涉及的商品信息，然后获取该商品所涉及到的优惠信息，如果商品不参与优惠信息，则无此环节。扣减库存规则是指订单中的商品，何时从仓储系统中对相应商品库存进行扣除。方式各有优缺点，需结合实际场景进行考虑，如：秒杀、抢购、促销活动等，可使用下单减库存的方式。而对于产品库存量大，并发流量没有那么强的产品使用付款减库存的方式。



**秒杀场景下如何扣减库存？**

- **采用下单减库存**

  因秒杀场景下，大部分用户都是想直接购买商品的，可以直接用下单减库存。大量用户和恶意用户都是同时进行的，区别是正常用户会直接购买商品，恶意用户虽然在竞争抢购的名额，但是获取到的资格和普通用户一样，所以下单减库存在秒杀场景下，恶意用户下单并不能造成之前说的缺点。而且下单直接扣减库存，这个方案更简单，在第一步就扣减库存了。

- **Redis 缓存**

  查询缓存要比查询数据库快，所以将库存数放在缓存中，直接在缓存中扣减库存。如果并发很高，还可以采取分布式锁的方案。

- **限流**

  秒杀场景中，对请求做了很多限流操作，如前端页面的限流和后端令牌桶限流，真正到扣减库存时，请求数很少了。



#### 下单减库存

即用户下单成功时减少库存数量。

**优势**：用户体验友好，系统逻辑简洁。

**缺点**：会导致恶意下单或下单后却不买，使得真正有需求的用户无法购买，影响真实销量。



**解决办法**

- **设置订单有效时间**：若订单创建成功N分钟不付款，则订单取消，库存回滚
- **限购**：用各种条件来限制买家的购买件数，比如一个账号、一个ip，只能买一件
- **风控**：从技术角度进行判断，屏蔽恶意账号，禁止恶意账号购买



#### 付款减库存

即用户支付完成并反馈给平台后再减少库存数量。

**优势**：减少无效订单带来的资源损耗。

**缺点**：因第三方支付返回结果存在时差，同一时间多个用户同时付款成功，会导致下单数目超过库存，商家库存不足容易引发断货和投诉，成本增加。



**解决办法**

- 付款前再次校验库存，如确认订单要付款时再验证一次，并友好提示用户库存不足
- 增加提示信息：在商品详情页，订单步骤页面提示不及时付款，不能保证有库存等



#### 预扣库存

下单页面显示最新的库存，下单后保留这个库存一段时间（比如10分钟），超过保留时间后，库存释放。若保留时间过后再支付，如果没有库存，则支付失败。

**优势**：结合下单减库存的优点，实时减库存，且缓解恶意买家大量下单的问题，保留时间内未支付，则释放库存。

**缺点**：保留时间内，恶意买家大量下单将库存用完。并发量很高的时候，依然会出现下单数超过库存数。



### 恶意下单

如何解决恶意买家下单的问题？这里的恶意买家指短时间内大量下单，将库存用完的买家。

- **限制用户下单数量**

  **优点**：限制恶意买家下单

  **缺点**：用户想要多买几件，被限制了，会降低销售量

- **标识恶意买家**

  通过标识用户设备id或会员id，将用户加入黑名单，不足之处是有些用户是模拟的，识别不出来是不是真正的恶意买家。



### 支付失败

如何解决下单成功而支付失败（库存不足）的问题？

- **备用库存**

  **优点**：缓解部分用户支付失败的问题。

  **缺点**：备用库存只能缓解问题，不能从根本上解决问题。另外备用库存针对普通商品可以，针对特殊商品这种库存少的，备用库存量也不会很大，还是会出现大量用户下单成功却因库存不足而支付失败的问题。



### 库存超卖

如何解决高并发下库存超卖的场景？库存超卖最简单的解释就是多成交了订单而发不了货。

**场景**：用户 A 和 B 成功下单，在支付时扣减库存，当前库存数为 10。因 A 和 B 查询库存时，都还有库存数，所以 A 和 B 都可以付款。

A 和 B 同时支付，A 和 B 支付完成后，可以看做两个请求`回调`后台系统扣减库存，有两个线程处理请求，两个线程查询出来的库存数 `inventory = 10`。

![库存超卖](F:/work/openGuide/Architecture/images/Architecture/库存超卖.png)

A 线程更新最终库存数 ：lastInventory = inventory - 1 = 9，

B 线程更新库存数： lastInventory = inventory - 1 = 9。

而实际最终的库存应是 8 才对，这样就出现库存超卖的情况，而发不出货。那如何解决库存超卖的情况呢？以下方案都是基于数据库层面的。

- **方案一：SQL语句直接更新库存，而不是先查询出来，然后赋值**

  ```mysql
  UPDATE [库存表] SET 库存数 - 1
  ```

- **方案二：SQL语句更新库存时，如果扣减库存后，库存数为负数，直接抛异常，利用事务的原子性进行自动回滚。**

- **方案三：利用SQL语句更新库存，防止库存为负数**

  ```mysql
  UPDATE [库存表] SET 库存数 - 1 WHERE 库存数 - 1 > 0
  ```

  如果影响条数大于1，则表示扣减库存成功，否则不更新库存，并退款。



### 订单拆分

用户支付完订单后，需要获取订单的支付信息，包括支付流水号、支付时间等。支付完订单接着就是等商家发货，但在发货过程中，根据平台业务模式的不同，可能会涉及到订单的拆分。订单拆分一般分两种：

- 一种是用户挑选的商品来自于不同渠道（自营与商家，商家与商家）
- 另一种是在SKU层面上拆分订单：不同仓库，不同运输要求的SKU，包裹重量体积限制等因素需要将订单拆分



### 异步处理

随着公司的发展你可能会发现你项目的**请求链路越来越长**，例如刚开始的电商项目，可以就是粗暴的扣库存、下单。慢慢地又加上积分服务、短信服务等。这一路同步调用下来客户可能等急了，这时候就是消息队列登场的好时机。

**调用链路长、响应就慢了**，并且相对于扣库存和下单，积分和短信没必要这么的 “及时”。因此只需要在下单结束那个流程，扔个消息到消息队列中就可以直接返回响应了。而且积分服务和短信服务可以并行的消费这条消息。可以看出消息队列可以**减少请求的等待，还能让服务异步并发处理，提升系统总体性能**。

![订单服务-异步处理](F:/work/openGuide/Architecture/images/Architecture/订单服务-异步处理.png)



### 服务解耦

上面我们说到加了积分服务和短信服务，这时候可能又要来个营销服务，之后领导又说想做个大数据，又来个数据分析服务等等。所以一般会选用消息队列来解决系统之间耦合的问题，订单服务把订单相关消息塞到消息队列中，下游系统谁要谁就订阅这个主题。

![订单服务-服务解耦](F:/work/openGuide/Architecture/images/Architecture/订单服务-服务解耦.jpg)



### 流量控制

后端服务相对而言都是比较弱的，因为业务较重，处理时间较长。如秒杀活动爆发式流量打过来可能就顶不住了，因此需要引入一个中间件来做缓冲，基于消息队列实现削峰填谷功效。

- 网关的请求先放入消息队列中，后端服务尽自己最大能力去消息队列中消费请求。超时的请求可以直接返回错误
- 当然还有一些服务特别是某些后台任务，不需要及时地响应，并且业务处理复杂且流程长，那么过来的请求先放入消息队列中，后端服务按照自己的节奏处理

上面两种情况分别对应着生产者生产过快和消费者消费过慢两种情况，消息队列都能在其中发挥很好的缓冲效果。

![订单服务-流量控制](F:/work/openGuide/Architecture/images/Architecture/订单服务-流量控制.jpg)



## 异常设计

### 超时关闭

下单后发布延迟消息至MQ，等延迟时间到后，MQ会通知应用该消息，然后检查是否已被支付，未被支付则关闭超时订单。



### 重复支付

![重复支付-下单流程](F:/work/openGuide/Architecture/images/Architecture/重复支付-下单流程.png)

如图是一个简化的下单流程，首先是提交订单，然后是支付。支付的话，一般是走支付网关（支付中心），然后支付中心与第三方支付渠道（微信、支付宝、银联）交互，支付成功以后，异步通知支付中心，支付中心更新自身支付订单状态，再通知业务应用，各业务再更新各自订单状态。

这个过程中经常可能遇到的问题是掉单，无论是超时未收到回调通知也好，还是程序自身报错也好，总之由于各种各样的原因，没有如期收到通知并正确的处理后续逻辑等等，都会造成用户支付成功了，但是服务端这边订单状态没更新，这个时候有可能产生投诉，或者用户重复支付。

由于③⑤造成的掉单称之为外部掉单，由④⑥造成的掉单我们称之为内部掉单。为了防止掉单，这里可以这样处理：

- 支付订单增加一个中间状态“支付中”，当同一个订单去支付的时候，先检查有没有状态为“支付中”的支付流水，当然支付（prepay）的时候要加个锁。支付完成以后更新支付流水状态的时候再讲其改成“支付成功”状态
- 支付中心这边要自己定义一个超时时间（比如：30秒），在此时间范围内如果没有收到支付成功回调，则应调用接口主动查询支付结果，比如10s、20s、30s查一次，如果在最大查询次数内没有查到结果，应做异常处理
- 支付中心收到支付结果以后，将结果同步给业务系统，可以发MQ，也可以直接调用，直接调用的话要加重试（比如：SpringBoot Retry）
- 无论是支付中心，还是业务应用，在接收支付结果通知时都要考虑接口幂等性，消息只处理一次，其余的忽略
- 业务应用也应做超时主动查询支付结果

对于上面说的超时主动查询可以在发起支付的时候将这些支付订单放到一张表中，用定时任务去扫。

为了防止订单重复提交，可以这样处理：

**创建订单的时候，用订单信息计算一个哈希值，判断redis中是否有key，有则不允许重复提交，没有则生成一个新key，放到redis中设置个过期时间，然后创建订单。其实就是在一段时间内不可重复相同的操作。**

附上微信支付最佳实践：

![微信支付最佳实践](F:/work/openGuide/Architecture/images/Architecture/微信支付最佳实践.png)



### 支付对账

![对账业务流程](F:/work/openGuide/Architecture/images/Architecture/对账业务流程.png)



### 支付掉单

一个最常见的支付平台架构关系如下所示：

![支付系统异常处理-支付平台](F:/work/openGuide/Architecture/images/Architecture/支付系统异常处理-支付平台.jpg)

上图我们是站在第三方支付公司支付角度，如果是自己公司的内部支付系统，那么外部商户这一块其实就是公司内部一些系统，比如说订单系统，而外部支付渠道其实就是第三方支付公司。我们以携程为例，在其上面发起一笔订单支付，将会经过三个系统：

- 携程创建订单，向第三方支付公司发起支付请求
- 第三方支付公司创建订单，并向工行发起支付请求
- 工行完成扣款操作，返回第三方支付公司
- 第三方支付完成订单更新并返回携程
- 携程变更订单状态

上面的流程，简单如下图所示：

![支付系统异常处理-携程](F:/work/openGuide/Architecture/images/Architecture/支付系统异常处理-携程.jpg)

在这个过程就可能会碰到，用户工行卡已经扣款，但是携程订单却还是待支付，我们通常将这种情况称为「掉单」。上述掉单的场景，多数是因为「③、⑤」环节信息丢失导致，这种掉单我们将其称为「外部掉单」。还有一种极少数的情况，收到 「③、⑤」环节返回信息，但是在「④、⑥」环节内部系统更新订单状态失败，从而导致丢失支付成功的信息，这类掉单由于是内部问题，我们通常将其称之为「内部掉单」。



#### 外部掉单

外部掉单是因为没有收到对端返回信息，这种情况极有可能是网络问题，也有可能对端处理逻辑太慢，导致我方请求超时，直接断开了网络请求。

**① 增加超时时间**

适当的增加超时时间，在增加网络超时时间之后，可能还需要调整整个链路的超时时间，不然有可能导致整个链路内部超时从而引起内部掉单。

**注意**：对接外部渠道，一定要「设置网络连接超时时间与读取超时时间」。

**② 接收异步通知**

接收渠道异步回执通知信息，一般来说，现在支付渠道接口都可以上送一个异步回调地址，当渠道端处理成功，将会把成功信息通知到这个回调地址上。这种情况下，只需要接收通知信息，然后解析，再更新内部订单状态。

![支付系统异常处理-支付异步通知](F:/work/openGuide/Architecture/images/Architecture/支付系统异常处理-支付异步通知.jpg)

**注意**

- 对于异步请求信息，一定需要对通知内容进行签名验证，并校验返回的订单金额是否与商户侧的订单金额一致，防止数据泄漏导致出现“假通知”，造成资金损失
- 异步通知将会发送多次，所以异步通知处理需要幂等

**③ 掉单查询**

有的渠道可能没有提供异步通知的功能，只提供了订单查询的接口，这种情况下，只能使用定时掉单查询解决。可以将这类超时未知的订单的单独保存到掉单表，然后定时向渠道端查询订单的状态。若查询成功或者明确失败（比如订单不存在等），可以更新订单状态，并且删除掉单表记录；若查询依旧未知，这时我们需要等待下次查询的结果。

![支付系统异常处理-定时查询](F:/work/openGuide/Architecture/images/Architecture/支付系统异常处理-定时查询.jpg)

**注意**：有些情况下，有可能无法查询返回订单的状态，所以需要设置订单查询的最大次数，防止无限查询浪费性能。

**④ 对账**

最后，极少数的情况下，订单查询与异步通知都无法获取的支付结果，这就只能进行对账处理。如果第二天渠道端给的对账文件有这一笔支付结果，那么可以根据这个记录更新直接更新内部支付记录。

**注意**：稳妥一点，可以先发起查询，然后根据查询结果更新订单记录。不过有些极端情况，查询无法获取结果，那么直接更新内部记录即可。那如果第二天也没有这笔记录的结果，这种情况下，我们可以认为这笔是失败的。如果用户被扣款，渠道端内部将会发起退款，将支付金额返回给用户。所以这种情况可以无需处理。



#### 内部掉单

**① 支付公司内部订单关系**

如下图所示，第三方支付公司内部表通常为支付订单与渠道订单这样一种 1 比 N 的关系：

![支付系统异常处理-支付订单渠道1N](F:/work/openGuide/Architecture/images/Architecture/支付系统异常处理-支付订单渠道1N.jpg)

**渠道订单**代表着第三方支付公司与外部渠道的关系，其实对**外部渠道系统**来讲，第三方支付公司就是一个外部商户。如果使用上图 1 对1 的订单关系，当第一次支付支付失败，外部商户可能会再次使用相同订单号对第三方支付公司发起支付。

![支付系统异常处理-支付订单渠道11](F:/work/openGuide/Architecture/images/Architecture/支付系统异常处理-支付订单渠道11.jpg)

如果第三方支付公司也拿相同的内部订单去请求外部渠道系统，有可能外部渠道系统并不支持同一订单号再次请求。但是现实的情况，很多外部商户并不是那么容易更换生成新的订单号，所以一般第三方支付公司都需要支持同一外部商户订单号在未成功的情况下，支持重复支付。在这种情况下，就需要我们上面的 1:N 的订单关系图了。



**② 内部掉单异常的原因**

当收到外部渠道系统的成功的返回信息，成功更新了渠道订单表的记录。但是由于渠道订单表与支付订单表可能不是同一个数据库，也有可能两者并不在同一个应用中，这就有可能导致更新支付订单表的更新失败。

![支付系统异常处理-内部掉单](F:/work/openGuide/Architecture/images/Architecture/支付系统异常处理-内部掉单.jpg)

由于支付订单是表保存着外部商户订单与内部订单关系，支付订单未成功，所以外部商户也无法查询得到成功的支付结果。

此时渠道订单表已经成功，所以上面外部掉单的方法并不适用内部掉单。



**内部掉单异常解决办法：**

- **分布式事务**

  内部掉单异常，说白就是因为支付订单表与渠道订单表无法使用数据库事务保证两者同时更新成功或失败。

- **异步补偿更新**

  当发生内部掉单的情况，即更新支付订单失败等情况，可以将这里支付订单保存（无法保证绝对成功）到一张内部掉单表。所以还需要定时查询，查询一段时间内支付订单未成功，而渠道订单表已成功的支付订单记录，然后也将其插入到内部掉单表。另一个系统应用，只需要定时扫描内部掉单表，将支付订单成功，然后再删除内部掉单记录即可。

**注意**：当支付订单表数据量很大后，定时查询可能会慢，为了防止影响主库，所以这类查询可以在备库进行。



#### 解决方案

支付掉单、卡单是支付过程中经常会碰到的事，可以采用异步补偿的方案，解决该问题。异步补偿方案可以采用如下两种：

- 定时轮询补偿方案
- 延迟消息补偿方案

定时轮询补偿方案实现起来比较简单，但是时效性稍差。而延迟消息补偿方案总体来说比较优秀，但是实现起来比较复杂。如果没有自定义的延迟时间的需求，可以直接采用 RocketMQ 延迟消息，简单快捷。另外**延迟队列**使用场景还是比较多，不仅仅能用在掉单补偿上，还可以用于支付关单等场景。所以有能力开发的团队，可以开发一个通用的延迟队列。



**方案一：定时轮询补偿方案**

**① 整体流程**

该方案主要采用定时任务，批量查询掉单记录，从而驱动查询具体支付结果，然后更新内部订单。整体方案流程图如下：

![支付掉单-定时任务补偿](F:/work/openGuide/Architecture/images/Architecture/支付掉单-定时任务补偿.jpg)

前三步流程没什么好说的，正常的支付流程，咱们针对后面几步具体详细说下。

第三步调用支付通道之后，如果支付通道端返回**支付受理成功或者支付处理中**，我们就需要调用第四步，将这类订单插入掉单表。如果支付直接成功了，那就正常流程返回即可。

> 复习一下，网关类支付，比如支付宝、微信支付、网银支付，这种支付模式，支付通道仅仅返回支付受理成功，具体支付结果需要接收支付通道端的支付通知，这类支付我们将其称为异步支付。相应的还有同步支付，比如银行卡支付，微信、支付宝代扣类支付，这类支付，同步就能返回支付结果。

第五步，补单应用将会定时查询数据库，批量查询掉单记录。

第六步，补单应用使用线程池，多线程异步的方式发起掉单查询。

第七步，调用支付通道支付查询接口。

重点来了，如果第七步支付结果查询为以下状态：

- **支付结果为扣款成功**
- **支付结果为明确失败**
- **掉单记录查询达到最大次数**

**第八步就会删除掉单记录。**

最后，如果掉单查询依旧还是处理中，那么经过一定的延时之后，重复第五步，再次重新掉单补偿，直到成功或者查询到达最大次数。

**② 相关问题**

**为什么需要新建一张掉单表？不能直接使用支付订单表，查询未成功的订单吗?**

这个问题，实际上确实可以直接使用的支付订单表，然后批量查询当天未成功的订单，补单程序发起支付查询。那为什么需要新建一张掉单表？主要是因为数据库查询效率问题，因为支付订单表每天都会大量记录新增，随着时间，这张表记录将会越来越多，越来越大。

**支付记录越多，批量范围查询效率就会变低，查询速度将会变慢**。所以为了查询效率，新建一张掉单表。这张表里仅记录支付未成功的订单，所以数据量就会很小，那么查询效率就会很高。另外，掉单表里的记录，不会被永久保存，只是临时性。当支付结果查询成功，或者支付结果明确失败，再或者查询次数到达规定最大次数，就会删除掉单记录。

**这就是第八步为什么需要删除掉单表的原因。**

如果需要保存每次掉单表查询详情，那么这里建议再新增一张掉单查询记录表，保存每一次的查询记录。针对这个方案，如果还有其他问题，欢迎留言。

**③ 方案优缺点**

定时轮询补偿方案，最大的优点可能就是系统架构方案比较简单，比较容易实施。那么这个方案的缺点主要在于**定时任务**上。定时任务轮询方案天然会存在以下不足：

- **轮询效率稍低**
- 每次查询数据库，已经被执行过记录，仍然会被扫描（补单程序将会根据一定策略决定是否发起支付通道查询），有**重复计算**的嫌疑
- **时效性不够好**，如果每小时轮询一次，最差的情况下，时间误差会达到1小时
- 如果为了解决时效性问题，增加定时任务查询效率，那么 1 中查询效率跟 2 的重复计算问题将会更加明显



**方案二：延迟消息补偿方案**

下面介绍另外一种掉单补偿方案，延迟消息补偿方案，这个方案整体流程与定时任务方案类似，最大区别可能在于，从一种**拉模式**变成一种**推模式**。

**① 整体流程**

整体方案流程图如下：

![支付掉单-延迟消息补偿方案](F:/work/openGuide/Architecture/images/Architecture/支付掉单-延迟消息补偿方案.jpg)

这个方案主要流程跟定时方案类似，主要区别在于第四步，第五步，第八步。

第四步的流程从插入掉单表变更为往**延迟队列发送掉单消息**。

第五步，补单程序接收掉单消息，然后触发支付掉单查询。

第八步，如果第七步支付结果查询为以下状态：

- 支付结果为扣款成功
- 支付结果为明确失败
- 掉单记录查询达到最大次数

补单程序将会告知延迟队列消费成功，延迟队列将会删除这条掉单消息。其他状态将会告知消费失效，延迟队列将会在一定延时之后，再次发送掉单消息，然后继续重复第五步。

**② 延迟队列**

这里的延迟队列需要自己实现，复杂度还是比较高的，这里给大家推荐几种实现方案：

第一种，基于 **Redis SortedSet** 实现延迟队列。可以参考一下有赞的实现方案https://tech.youzan.com/queuing_delay/

第二种，基于时间轮算法(**TimingWheel**)实现延迟队列，具体可以参考 Kafka 延时队列。

第三种，基于 **RocketMQ** 延迟消息。

前两种方案说起来还需要再开发，所以还是比较复杂的。这里重点说下第三种方案，该方案是 **RocketMQ** 已经支持的特性，开箱即用，使用起来还是比较简单的。RocketMQ 延迟消息支持 18 个等级，分别如下：

```properties
1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
```

消息发送方可以通过Message.setDelayTimeLevel方式指定延迟等级，对应上方的延迟时间。消息消费方，如果消费失败，默认将会在消息发送方的的延迟等级基础上加 1。如果消息消费方需要指定其他的延迟等级，可以使用ConsumeConcurrentlyContext.setDelayLevelWhenNextConsume方式。RocketMQ 延迟消息，支持的特性还是比较基础、简单，不支持自定义延迟时间。不过对于掉单补偿的这个场景刚好够用，但是如果需要自定义延迟的，那还是得采用其他的方案。

**③ 方案优缺点**

延迟消息的方案相对于定时轮询方案来讲：

- 无需再查询全部订单，效率高
- 时效性较好

不过延迟消息这种方案，需要基于**延迟队列**，实现起来比较复杂，目前开源实现也比较少。