
您查询的关键词是：[规则引擎](http://cache.baiducontent.com/c?m=48G-KOPZXH9SdL8E7NhfI0mzbIFfuq7nBSAJCsUa8RngN8Eu5mHI0ecuCNlqQGZfxq69Uw6HPi0GTysmj1DtvZGF1RY3fCEPJ9n0jVraoArdNhaaFK6ug-JMCZH1eFB4Ukdgv1mZ_9ZQA6YG-K9z6ONTVEHbdPy0exNGhmNSlva&p=8b2a97049daf5aee08e2907b5840&newp=c0759a41d39d03f30ca9c7710f5e92695d0fc20e38ddd701298ffe0cc4241a1a1a3aecbf2c281200d3c57d6201ac4b57e0f335763d0034f1f689df08d2ecce7e71ca7b6034&s=c6731d63da166527&user=baidu&fm=sc&query=%B9%E6%D4%F2%D2%FD%C7%E6&qid=c7f01fd9000786c4&p1=2#baidusnap0)

如果打开速度慢，可以尝试[快速版](http://cache.baiducontent.com/c?m=48G-KOPZXH9SdL8E7NhfI0mzbIFfuq7nBSAJCsUa8RngN8Eu5mHI0ecuCNlqQGZfxq69Uw6HPi0GTysmj1DtvZGF1RY3fCEPJ9n0jVraoArdNhaaFK6ug-JMCZH1eFB4Ukdgv1mZ_9ZQA6YG-K9z6ONTVEHbdPy0exNGhmNSlva&p=8b2a97049daf5aee08e2907b5840&newp=c0759a41d39d03f30ca9c7710f5e92695d0fc20e38ddd701298ffe0cc4241a1a1a3aecbf2c281200d3c57d6201ac4b57e0f335763d0034f1f689df08d2ecce7e71ca7b6034&s=c6731d63da166527&user=baidu&fm=sc&query=%B9%E6%D4%F2%D2%FD%C7%E6&qid=c7f01fd9000786c4&p1=2&fast=y)；如果想更新或删除快照，可以[投诉快照](http://help.baidu.com/newadd?prod_id=1&category=1&link=http%3A%2F%2Fcache.baiducontent.com%2Fc%3Fm%3D48G-KOPZXH9SdL8E7NhfI0mzbIFfuq7nBSAJCsUa8RngN8Eu5mHI0ecuCNlqQGZfxq69Uw6HPi0GTysmj1DtvZGF1RY3fCEPJ9n0jVraoArdNhaaFK6ug-JMCZH1eFB4Ukdgv1mZ_9ZQA6YG-K9z6ONTVEHbdPy0exNGhmNSlva%26p%3D8b2a97049daf5aee08e2907b5840%26newp%3Dc0759a41d39d03f30ca9c7710f5e92695d0fc20e38ddd701298ffe0cc4241a1a1a3aecbf2c281200d3c57d6201ac4b57e0f335763d0034f1f689df08d2ecce7e71ca7b6034%26s%3Dc6731d63da166527%26user%3Dbaidu%26fm%3Dsc%26query%3D%B9%E6%D4%F2%D2%FD%C7%E6%26qid%3Dc7f01fd9000786c4%26p1%3D2)。

百度和网页 [http://www.choupangxia.com/2021/01/23/rule%2Dengine%2D4/](http://www.choupangxia.com/2021/01/23/rule-engine-4/) 的作者无关，不对其内容负责。百度快照谨为网络故障时之索引，不代表被搜索网站的即时页面。

[跳转到内容](http://www.choupangxia.com/2021/01/23/rule-engine-4/#content)

[程序新视界](http://www.choupangxia.com/)

开启程序员的新视界

- [SPRING CLOUD](http://www.choupangxia.com/category/springcloud/)
- [SPRING BOOT](http://www.choupangxia.com/category/spring-boot/)
- [**规则引擎**](http://www.choupangxia.com/category/规则引擎/)
- [区块链](http://www.choupangxia.com/category/blockchain/)
- [程序人生](http://www.choupangxia.com/category/life/)
- [JAVA](http://www.choupangxia.com/category/java/)
- [运维](http://www.choupangxia.com/category/运维/)
- [面试题](http://www.choupangxia.com/category/面试/)
- [视频教程](http://www.choupangxia.com/video-page/)

# [什么是**规则引擎**(DROOLS、OPENL TABLETS、EASY RULES、RULEBOOK)](http://www.choupangxia.com/2021/01/23/rule-engine-4/)

-  发表于：[2021年1月23日](http://www.choupangxia.com/2021/01/23/rule-engine-4/)
-  分类：[Drools](http://www.choupangxia.com/category/drools/), [**规则引擎**](http://www.choupangxia.com/category/规则引擎/)
-  标签：[Drools](http://www.choupangxia.com/tag/drools/), [Easy-Rules](http://www.choupangxia.com/tag/easy-rules/), [OpenL Tablets](http://www.choupangxia.com/tag/openl-tablets/), [RuleBook](http://www.choupangxia.com/tag/rulebook/), [**规则引擎**](http://www.choupangxia.com/tag/规则引擎/)
- 

**什么是\**规则引擎\****

**规则引擎**是根据一些算法执行规则的一些列软件系统。**规则引擎**整合了传入系统的Fact集合和规则集合，从而去触发一个或多个业务操作。规则通常以声明式的方式在业务代码中实现，我们可能以为它很少会被改变。但事实上，这些业务逻辑的判断条件经常会被改变。

在本篇文章中的业务逻辑或规则，通常是可以表示为“在某写条件下，执行某些任务”。

在拥有大量规则和Fact对象的业务系统中，可能会出现多个Fact输入都会导致同样的输出，这种情况我们通常称作规则冲突。**规则引擎**可以采用不同的冲突解决方案来确定冲突规则的执行顺序。在**规则引擎**中，通常有两种执行方式：


**正向链接**：这是一种基于“数据驱动”的形式，基于插入的Fact对象和Fact对象的更新，**规则引擎**利用可用的Fact推理规则来提取出更多的Fact对象，直到计算出最终目标，最终会有一个或多个规则被匹配，并计划执行。因此，**规则引擎**始于事实，始于结论。


**反向链接**：这是一种基于“目标驱动”或推理形式，与正向链接相反。反向链条从**规则引擎**假设的结论开始，如果不能够直接满足这些假设，则搜索可满足假设的子目标。**规则引擎**会循环执行这一过程，直到证明结论或没有更多可证明的子目标为止。

***\*规则引擎\**与流程处理的区别**

规则与过程的不同之处主要在于：业务流程代表业务做了什么；**规则引擎**代表决定做什么业务。


**规则引擎**可以被视为复杂的if / then语句解释器。被解释的if / then语句称为规则。


规则的if部分用于处理条件，比如account.getMoney() < 0；规则的then部分包含执行的操作，比如sendWarning(account)。

```
if (account.getMoney() < 0)
sendWarning(account);
```

![什么是规则引擎(Drools、OpenL Tablets、Easy Rules、RuleBook)插图](https://www.choupangxia.com/wp-content/uploads/2021/01/image-13-1024x539.png)

规则存储在正向链接**规则引擎**中，即引擎执行一个执行周期，该周期允许一个规则的操作触发其他规则的条件得到满足。这样，级联的规则会被激活，同时每条规则的操作都会被执行。正向链接的**规则引擎**适用于从简单输入（Fact）得出高层次的结论的场景。

上面的代码示例，通过**规则引擎**可写成如下形式：

```
global AccountManager manager;

rule "checkMoney"
when
$account : Account( money < 0 )
then
  manager.warn($account);
end
```

显而易见，一个规则文件是由两个概念组成：
**规则**：用于控制业务流程的声明式语句。一个规则通常包含判断条件部分和执行操作部分。如果条件评估结果为true，则执行**规则引擎**操作部分。
**Fact**：规则执行所需要的数据。在上面的示例中Account便是Fact对象。

***\*规则引擎\**的优势**

使用**规则引擎**可以给系统带来如下优势：
**高灵活性**：在规则保存在知识库中，可以在规则变动轻易做出修改。
**容易掌控**：规则比过程代码更易于理解，因此可以有效地来弥补业务分析师和开发人员之间的沟通问题。
**降低复杂度**：在程序中编写大量的判断条件，很可能是会造成一场噩梦。使用**规则引擎**却能够通过一致的表示形式，更好的处理日益复杂的业务逻辑。
**可重用性**：规则集中管理，可提高业务的规则的可重用性。而且，传统的代码程序通常会添加不必要的变数，很然进行重复利用。


需要留意的是，在业务规则没有太多变动，业务规则比较简单的情况下，是没有必要使用**规则引擎**的。

**开源\**规则引擎\****

Drools**规则引擎**是一款开源的**规则引擎**，地址为：https://drools.org/ 。Drools**规则引擎**可通过存储、处理和评估数据来执行业务规则和决策模型。Drools**规则引擎**最基础的功能是将输入的数据或Fact对象和规则条件进行匹配，并根据匹配结果决定如何执行规则。


Drools**规则引擎**基于以下组件运行：
**规则**：业务规则或DMN决策。所有规则必须至少包含触发该规则的条件以及对应的操作。

**Fact**：输入到**规则引擎**的数据，用于规则的条件的匹配。

**生产内存**：**规则引擎**中规则存储的地方。

**工作内存**：**规则引擎**中Fact对象存储的地方。

**议程**：用于存储被激活的规则的分类和排序的地方。

当用户或系统在Drools中添加或更新规则相关的信息时，该信息会以一个或多个Fact的形式插入Drools**规则引擎**的工作内存中。Drools**规则引擎**匹配Fact和存储在生产内存中规则，筛选符合执行条件的规则。对于满足条件的规则，**规则引擎**会在议程中激活和注册对应的规则，在议程中Drools会进行优先级的排序和冲突的解决，准备规则的执行。

下图概述了相关操作：

![什么是规则引擎(Drools、OpenL Tablets、Easy Rules、RuleBook)插图1](https://www.choupangxia.com/wp-content/uploads/2021/01/image-14-1024x318.png)

Drools引擎是KIE（知识就是一切）项目的一部分，该项目除了Drools之外还包括：

jBPM：jBPM是一种灵活的业务流程管理组件，允许你通过描述实现这些目标所需执行的步骤来对业务目标进行建模。

OptaPlanner是一个约束解决器，可以优化用例，例如员工排班，车辆路线，任务分配和云优化。

Business Central是功能齐全的Web应用程序，用于可视化组成自定义业务规则和流程。

UberFire是一个基于Web的工作台框架，其灵感来自Eclipse Rich Client Platform。

Drool规则的示例，留意一下的Java Bean模型和示例DRL规则：

```
public class Applicant {
  private String name;
  private int age;
  private boolean valid;
  // Getter and setter methods
}
```

下面是一个用于检查申请人年龄的简单DRL规则示例：

```
package com.company.license

rule "Is of valid age"
when
  $a : Applicant(age < 18)
then
  $a.setValid(false);
end
```

上述规则，对于未满18岁的申请人，将会拒绝。

```
//Create the KIE container
KieServices kieServices = KieServices.Factory.get();

KieContainer kContainer = kieServices.getKieClasspathContainer();

//Instantiate the stateless KIE session and enter data
StatelessKieSession kSession = kContainer.newStatelessKieSession();

Applicant applicant = new Applicant("Mr John Smith", 16);

assertTrue(applicant.isValid());

ksession.execute(applicant);

assertFalse(applicant.isValid());
```

**OpenL Tablets**

OpenL Tablets（http://openl-tablets.org/）是基于Excel文档的业务规则管理系统和业务**规则引擎**。基于独特的概念，OpenL Tablets有助于将包含业务逻辑规范的业务文档视为可执行源代码。由于企业用户熟悉OpenL Tablets使用的表格式，因此OpenL Tablets弥补了企业用户和开发人员之间的鸿沟，从而减少了昂贵的企业软件开发错误，并大大缩短了软件开发周期。 简单来说，可以将OpenL Tablets视为表处理器，该处理器可从Excel文档中提取表并可以通过应用程序访问。

OpenL Tablets主要优点：

- OpenL Tablets消除了软件实施与业务文档，规则和策略之间的鸿沟。
- 业务规则对开发人员变得透明。
- OpenL Tablets验证所有项目文档数据中的语法和类型错误，从而提供方便且详细的错误报告。 OpenL Tablets可以直接指向Excel文档中的问题。
- OpenL Tablets提供了计算解释功能，可以通过指向原始文档中的源参数来扩展任何计算结果。
- OpenL Tablets使用户能够创建和维护测试，以确保所有规则的可靠工作。
- OpenL Tablets在所有项目文档中提供交叉索引和搜索功能。
- OpenL Tablets通过其业务规则管理应用程序提供完整的规则生命周期支持。
- OpenL Tablets支持.xls和.xlsx文件格式。

使用OpenL Tablets API可访问Excel表中的规则和数据。 OpenL Tablets提供了一个包装器，以方便使用。 例如，考虑以下在Excel文档中编码的规则：

![什么是规则引擎(Drools、OpenL Tablets、Easy Rules、RuleBook)插图2](https://www.choupangxia.com/wp-content/uploads/2021/01/image-15-1024x412.png)

在hello1中只有一个规则：

```
public interface Simple {
    void hello1(int i);
}
```

基于包装器运行规则：

```
import static java.lang.System.out;
import org.openl.rules.runtime.RulesEngineFactory;
public class Example {
    public static void main(String[] args) {
        //define the interface
        RulesEngineFactory < Simple > rulesFactory =
            new RulesEngineFactory < Simple > ("TemplateRules.xls",
                Simple.class);
        Simple rules = (Simple) rulesFactory.newInstance();
        rules.hello1(12);
    }
}
```

使用OpenL Tablets，需要引入如下依赖：

```
<dependency>
    <groupId>com.deliveredtechnologies</groupId>
    <artifactId>rulebook-core</artifactId>
    <version>0.11</version>
</dependency>
```

**Easy Rules**

Easy Rules（https://github.com/j-easy/easy-rules）是一个简单但功能强大的Java**规则引擎**，提供以下功能：

- 轻巧的框架和易于学习的API
- 基于POJO的开发
- 抽象定义业务规则，可轻松使用
- 支持从原始规则创建复合规则
- 支持使用表达式语言（如MVEL和SpEL）定义规则

简而言之，Easy Rules提供了Rule抽象以创建具有条件和操作的规则，并提供了RuleEngine API，该API通过一组规则去评估条件并执行操作。
要使Easy Rules需引入以下依赖项到pom.xml中：

```
<dependency>
    <groupId>org.jeasy</groupId>
    <artifactId>easy-rules-core</artifactId>
    <version>3.4.0</version>
</dependency>
```

创建一个始终会触发，并打印“hello word”到控制台的规则：

```
@Rule(name = "Hello World rule", description = "Always say hello world")
public class HelloWorldRule {

    @Condition
    public boolean when() {
        return true;
    }

    @Action
    public void then() throws Exception {
        System.out.println("hello world");
    }
}
```

创建**规则引擎**，并触发规则：

```
public class Launcher {

    public static void main(String[] args) {

        // create facts
        Facts facts = new Facts();

        // create rules
        Rules rules = new Rules();
        rules.register(new HelloWorldRule());

        // create a rules engine and fire rules on known facts
        RulesEngine rulesEngine = new DefaultRulesEngine();
        rulesEngine.fire(rules, facts);

    }
}
```

**RuleBook\**规则引擎\****

厌倦了充斥着if/then/else语句类？是否需要一个很好的抽象方法，以使规则彼此分离的方式轻松指定规则？是否要像编写其余代码一样编写规则？RuleBook可能是你要选择的规则抽象。

RuleBook是一个**规则引擎**，旨在以Java开发人员熟悉的方式创建规则。RuleBook还允许你使用易于使用的启用Lambda的特定领域语言或自定义的POJO来指定规则。

使用RuleBook需要引入以下依赖到pom.xml中：

```
<dependency>
    <groupId>com.deliveredtechnologies</groupId>
    <artifactId>rulebook-core</artifactId>
    <version>0.11</version>
</dependency>
```

使用示例：

```
public class ExampleRule {
    public RuleBook<Object> defineHelloWorldRules() {
        return RuleBookBuilder
          .create()
            .addRule(rule -> rule.withNoSpecifiedFactType()
              .then(f -> System.out.print("Hello ")))
            .addRule(rule -> rule.withNoSpecifiedFactType()
              .then(f -> System.out.println("World")))
            .build();
    }
}
```

通过以下方式执行：

```
public static void main(String[] args) {
    ExampleRule ruleBook = new ExampleRule();
    ruleBook
      .defineHelloWorldRules()
      .run(new FactMap<>());
}
```





------

![什么是规则引擎(Drools、OpenL Tablets、Easy Rules、RuleBook)插图3](http://www.choupangxia.com/wp-content/uploads/2020/03/qrcode_for_gh_d4572c51e545_344.jpg)

关注公众号：**程序新视界**，一个让你软实力、硬技术同步提升的平台

除非注明，否则均为[程序新视界](http://www.choupangxia.com/)原创文章，转载必须以链接形式标明本文链接

本文链接：http://www.choupangxia.com/2021/01/23/rule-engine-4/

## 文章导航

[前一页上一篇：如何将一个项目同时提交到GitHub和Gitee(码云)上](http://www.choupangxia.com/2021/01/23/github-and-gitee/)

[后一页下一篇：02 不解释，全网最全Shiro认证与授权原理分析](http://www.choupangxia.com/2021/01/25/shiro-02/)

![img](http://1.gravatar.com/avatar/ac104dd5de81f816d4e7e8dad83b5ee8?s=70&d=mm&r=g)

### [SECBRO2](http://www.choupangxia.com/author/secbro2/)

程序新视界，一个软实力、硬知识同时提升的平台

[**818**](http://www.choupangxia.com/author/secbro2/)

#### 搜索

搜索：搜索

#### 微信公号：程序新视界

[![程序新视界](http://www.choupangxia.com/wp-content/uploads/2019/07/weixin.jpg)](http://www.choupangxia.com/wp-content/uploads/2019/07/weixin.jpg)一个软技能、硬实力同时提升的公众号。

#### SPRING BOOT出版书籍

[![img](http://www.choupangxia.com/wp-content/uploads/2020/06/3cf2897383742e0e-300x300.jpg)](https://item.jd.com/12680075.html)

#### 视频教程

[《Spring Boot 视频教程全家桶》](https://edu.csdn.net/course/detail/20369)
[《Drools7基础和Workbench实战套餐》](https://edu.csdn.net/combo/detail/1575) [《Drools 7系列优惠套餐》](https://edu.csdn.net/combo/detail/1142)
[《Drools 7 **规则引擎**入门教程》](http://edu.csdn.net/course/detail/5523)
[《Drools 7 **规则引擎**进阶教程》](http://edu.csdn.net/course/detail/10555)
[《Drools**规则引擎**之决策表从入门到精通》](https://edu.csdn.net/course/detail/28052)



#### 分类目录

- [docker](http://www.choupangxia.com/category/运维/docker/)
- [drools](http://www.choupangxia.com/category/drools/)
- [fastdfs](http://www.choupangxia.com/category/fastdfs/)
- [freemarker](http://www.choupangxia.com/category/前端/freemarker/)
- [geth](http://www.choupangxia.com/category/blockchain/geth/)
- [git](http://www.choupangxia.com/category/git/)
- [IDEA](http://www.choupangxia.com/category/idea/)
- [Java](http://www.choupangxia.com/category/java/)
- [JavaFx](http://www.choupangxia.com/category/javafx/)
- [jqGrid](http://www.choupangxia.com/category/前端/jqgrid/)
- [jvm](http://www.choupangxia.com/category/java/jvm/)
- [LeetCode算法](http://www.choupangxia.com/category/leetcode算法/)
- [Linux](http://www.choupangxia.com/category/运维/linux/)
- [Maven](http://www.choupangxia.com/category/maven/)
- [mqtt](http://www.choupangxia.com/category/mqtt/)
- [mybatis](http://www.choupangxia.com/category/java/mybatis/)
- [mysql](http://www.choupangxia.com/category/数据库/mysql/)
- [nacos](http://www.choupangxia.com/category/nacos/)
- [netty](http://www.choupangxia.com/category/netty/)
- [Nginx](http://www.choupangxia.com/category/运维/nginx/)
- [postGreSQL](http://www.choupangxia.com/category/数据库/postgresql/)
- [redis](http://www.choupangxia.com/category/运维/redis/)
- [shiro](http://www.choupangxia.com/category/shiro/)
- [slf4j](http://www.choupangxia.com/category/slf4j/)
- [solidity](http://www.choupangxia.com/category/blockchain/solidity/)
- [spring](http://www.choupangxia.com/category/java/spring/)
- [spring](http://www.choupangxia.com/category/spring-2/)
- [Spring Boot](http://www.choupangxia.com/category/spring-boot/)
- [Spring Cloud](http://www.choupangxia.com/category/springcloud/)
- [vue](http://www.choupangxia.com/category/前端/vue/)
- [wildfly](http://www.choupangxia.com/category/wildfly/)
- [zk](http://www.choupangxia.com/category/运维/zk/)
- [其他](http://www.choupangxia.com/category/uncategorized/)
- [前端](http://www.choupangxia.com/category/前端/)
- [区块链](http://www.choupangxia.com/category/blockchain/)
- [单元测试](http://www.choupangxia.com/category/单元测试/)
- [实战](http://www.choupangxia.com/category/实战/)
- [微服务](http://www.choupangxia.com/category/微服务/)
- [数据库](http://www.choupangxia.com/category/数据库/)
- [日志](http://www.choupangxia.com/category/java/日志/)
- [架构](http://www.choupangxia.com/category/架构/)
- [消息队列](http://www.choupangxia.com/category/运维/消息队列/)
- [物联网](http://www.choupangxia.com/category/物联网/)
- [程序人生](http://www.choupangxia.com/category/life/)
- [**规则引擎**](http://www.choupangxia.com/category/规则引擎/)
- [设计模式](http://www.choupangxia.com/category/设计模式/)
- [读书](http://www.choupangxia.com/category/读书/)
- [跨境支付](http://www.choupangxia.com/category/跨境支付/)
- [运维](http://www.choupangxia.com/category/运维/)
- [面试](http://www.choupangxia.com/category/面试/)
- [项目实战](http://www.choupangxia.com/category/项目实战/)

#### 近期文章

- [Nacos基于RestTemplate方式的调用](http://www.choupangxia.com/2021/07/04/nacos-resttemplate/)
- [微服务之：服务挂的太干脆，Nacos还没反应过来，怎么办？](http://www.choupangxia.com/2021/07/02/springcloud-nacos-beat/)
- [Nacos服务自动关闭问题汇总](http://www.choupangxia.com/2021/06/29/nacos-shutdown/)
- [Nacos 内存参数修改调优](http://www.choupangxia.com/2021/06/29/nacos-jvm/)
- [微服务之吐槽一下Nacos日志的疯狂输出](http://www.choupangxia.com/2021/06/29/nacos-logs/)

#### 文章归档

- [2021年7月](http://www.choupangxia.com/2021/07/)
- [2021年6月](http://www.choupangxia.com/2021/06/)
- [2021年5月](http://www.choupangxia.com/2021/05/)
- [2021年4月](http://www.choupangxia.com/2021/04/)
- [2021年3月](http://www.choupangxia.com/2021/03/)
- [2021年2月](http://www.choupangxia.com/2021/02/)
- [2021年1月](http://www.choupangxia.com/2021/01/)
- [2020年12月](http://www.choupangxia.com/2020/12/)
- [2020年11月](http://www.choupangxia.com/2020/11/)
- [2020年10月](http://www.choupangxia.com/2020/10/)
- [2020年9月](http://www.choupangxia.com/2020/09/)
- [2020年8月](http://www.choupangxia.com/2020/08/)
- [2020年7月](http://www.choupangxia.com/2020/07/)
- [2020年6月](http://www.choupangxia.com/2020/06/)
- [2020年5月](http://www.choupangxia.com/2020/05/)
- [2020年4月](http://www.choupangxia.com/2020/04/)
- [2020年3月](http://www.choupangxia.com/2020/03/)
- [2020年2月](http://www.choupangxia.com/2020/02/)
- [2020年1月](http://www.choupangxia.com/2020/01/)
- [2019年12月](http://www.choupangxia.com/2019/12/)
- [2019年11月](http://www.choupangxia.com/2019/11/)
- [2019年10月](http://www.choupangxia.com/2019/10/)
- [2019年9月](http://www.choupangxia.com/2019/09/)
- [2019年8月](http://www.choupangxia.com/2019/08/)
- [2019年7月](http://www.choupangxia.com/2019/07/)
- [2018年3月](http://www.choupangxia.com/2018/03/)

#### 友链

[Felordcn](https://www.felord.cn/)
[日拱一兵](https://dayarch.top/)
[Cryptospace](https://dbarobin.com/)
[bugstack虫洞栈](https://bugstack.cn/)

[© 2021 程序新视界.](http://www.choupangxia.com/) [由 WordPress 强力驱动.](https://wordpress.org/) [WordStar](https://linesh.com/projects/wordstar/), [主题由Linesh Jose提供](https://linesh.com/)

# Java各种规则引擎

[![img](https://upload.jianshu.io/users/upload_avatars/5795126/7eccb88c-38e4-4d75-bde6-b79477be37f0.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)](https://www.jianshu.com/u/26d88371e1ff)

[HaleyLiu](https://www.jianshu.com/u/26d88371e1ff)关注

92018.12.26 20:07:18字数 1,245阅读 114,436

#### 一. Drools规则引擎

1. 简介：



```undefined
Drools就是为了解决业务代码和业务规则分离的引擎。
Drools 规则是在 Java 应用程序上运行的，其要执行的步骤顺序由代码确定
，为了实现这一点，Drools 规则引擎将业务规则转换成执行树。
```

1. 特性：



```undefined
优点：
　　　1、简化系统架构，优化应用
　　　2、提高系统的可维护性和维护成本
　　　3、方便系统的整合
　　　4、减少编写“硬代码”业务规则的成本和风险
```

3.原理：



![img](https://upload-images.jianshu.io/upload_images/5795126-c261d9316b10330e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

Drools.png

1. 使用方式：

(1)Maven 依赖：



```xml
<dependencies>
    <dependency>
        <groupId>org.kie</groupId>
        <artifactId>kie-api</artifactId>
        <version>6.5.0.Final</version>
    </dependency>
    <dependency>
        <groupId>org.drools</groupId>
        <artifactId>drools-compiler</artifactId>
        <version>6.5.0.Final</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
</dependencies>
```

（2）新建配置文件/src/resources/META-INF/kmodule.xml



```xml
<?xml version="1.0" encoding="UTF-8"?>
<kmodule xmlns="http://jboss.org/kie/6.0.0/kmodule">
    <kbase name="rules" packages="rules">
        <ksession name="myAgeSession"/>
    </kbase>
</kmodule>
```

（3）新建drools规则文件/src/resources/rules/age.drl



```kotlin
import com.lrq.wechatDemo.domain.User               // 导入类

dialect  "mvel"

rule "age"                                      // 规则名，唯一
    when
        $user : User(age<15 || age>60)     //规则的条件部分
    then
        System.out.println("年龄不符合要求！");
end
```

工程搭建完毕，效果如图：

![img](https://upload-images.jianshu.io/upload_images/5795126-de3fc653b88dda33.png?imageMogr2/auto-orient/strip|imageView2/2/w/654/format/webp)

项目结构.png

测试用例：



```java
/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/26
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath*:applicationContext.xml"})
public class TestUser {

    private static KieContainer container = null;
    private KieSession statefulKieSession = null;

    @Test
    public void test(){
        KieServices kieServices = KieServices.Factory.get();
        container = kieServices.getKieClasspathContainer();
        statefulKieSession = container.newKieSession("myAgeSession");
        User user = new User("duval yang",12);
        statefulKieSession.insert(user);
        statefulKieSession.fireAllRules();
        statefulKieSession.dispose();

    }



}
```

------

#### 二.Aviator表达式求值引擎

1. 简介：



```undefined
Aviator是一个高性能、轻量级的java语言实现的表达式求值引擎，主要用于各
种表达式的动态求值。现在已经有很多开源可用的java表达式求值引擎，为什
么还需要Avaitor呢？

Aviator的设计目标是轻量级和高性能 ，相比于Groovy、JRuby的笨重，Aviator
非常小，加上依赖包也才450K,不算依赖包的话只有70K；当然，Aviator的语法
是受限的，它不是一门完整的语言，而只是语言的一小部分集合。

其次，Aviator的实现思路与其他轻量级的求值器很不相同，其他求值器一般都
是通过解释的方式运行，而Aviator则是直接将表达式编译成Java字节码，交给
JVM去执行。简单来说，Aviator的定位是介于Groovy这样的重量级脚本语言和
IKExpression这样的轻量级表达式引擎之间。
```

1. 特性：



```bash
（1）支持大部分运算操作符，包括算术操作符、关系运算符、逻辑操作符、
正则匹配操作符(=~)、三元表达式?: ，并且支持操作符的优先级和括号强制优
先级，具体请看后面的操作符列表。
（2）支持函数调用和自定义函数。
（3）支持正则表达式匹配，类似Ruby、Perl的匹配语法，并且支持类Ruby的
$digit指向匹配分组。自动类型转换，当执行操作的时候，会自动判断操作数类
型并做相应转换，无法转换即抛异常。
（4）支持传入变量，支持类似a.b.c的嵌套变量访问。
（5）性能优秀。
（6）Aviator的限制，没有if else、do while等语句，没有赋值语句，仅支持逻
辑表达式、算术表达式、三元表达式和正则匹配。没有位运算符
```

1. 整体结构：

   ![img](https://upload-images.jianshu.io/upload_images/5795126-c6d444bdc6755e7a.png?imageMogr2/auto-orient/strip|imageView2/2/w/544/format/webp)

   整体结构.png

2. maven依赖：



```xml
<dependency>
    <groupId>com.googlecode.aviator</groupId>
    <artifactId>aviator</artifactId>
    <version>${aviator.version}</version>
</dependency>
```

1. 执行方式
   执行表达式的方法有两个：execute()、exec();
   execute()，需要传递Map格式参数
   exec(),不需要传递Map
   示例：



```dart
/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/25
 */
public class Test {
    public static void main(String[] args) {
        // exec执行方式，无需传递Map格式
        String age = "18";
        System.out.println(AviatorEvaluator.exec("'His age is '+ age +'!'", age));



        // execute执行方式，需传递Map格式
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("age", "18");
        System.out.println(AviatorEvaluator.execute("'His age is '+ age +'!'", 
map));

    }
}
```

1. 使用函数
   Aviator可以使用两种函数：内置函数、自定义函数
   （1）内置函数

   ![img](https://upload-images.jianshu.io/upload_images/5795126-c3dcfe5254ba9919.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

   Aviator内置函数.png

![img](https://upload-images.jianshu.io/upload_images/5795126-ecb71dc3a1439d02.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

Aviator内置函数.png



```cpp
/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/25
 */
public class Test {
    public static void main(String[] args) {
        Map<String,Object> map = new HashMap<>();
        map.put("s1","123qwer");
        map.put("s2","123");

  System.out.println(AviatorEvaluator.execute("string.startsWith(s1,s2)",map));

    }
}
```

（2）自定义函数

自定义函数要继承AbstractFunction类，重写目标方法。



```csharp
/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/25
 */
public class Test {
    public static void main(String[] args) {
        // 注册自定义函数
        AviatorEvaluator.addFunction(new MultiplyFunction());
        // 方式1
        System.out.println(AviatorEvaluator.execute("multiply(12.23, -2.3)"));
        // 方式2
        Map<String, Object> params = new HashMap<>();
        params.put("a", 12.23);
        params.put("b", -2.3);
        System.out.println(AviatorEvaluator.execute("multiply(a, b)", params));
    }

}

class MultiplyFunction extends AbstractFunction{
    @Override
    public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {

        double num1 = FunctionUtils.getNumberValue(arg1, env).doubleValue();
        double num2 = FunctionUtils.getNumberValue(arg2, env).doubleValue();
        return new AviatorDouble(num1 * num2);
    }

    @Override
    public String getName() {
        return "multiply";
    }

}
```

1. 常用操作符的使用
   （1）操作符列表

   ![img](https://upload-images.jianshu.io/upload_images/5795126-13a2dc39063b6524.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

   操作符列表.png

（2）常量和变量



![img](https://upload-images.jianshu.io/upload_images/5795126-4d138690483523e3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1020/format/webp)

常量和变量.png

（3）编译表达式



```jsx
/**
* CreateBy: haleyliu
* CreateDate: 2018/12/25
*/
public class Test {
   public static void main(String[] args) {
       String expression = "a+(b-c)>100";
       // 编译表达式
       Expression compiledExp = AviatorEvaluator.compile(expression);

       Map<String, Object> env = new HashMap<>();
       env.put("a", 100.3);
       env.put("b", 45);
       env.put("c", -199.100);

       // 执行表达式
       Boolean result = (Boolean) compiledExp.execute(env);
       System.out.println(result);

   }
}
```

(4) 访问数组和集合
List和数组用list[0]和array[0]，Map用map.date



```cpp
/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/25
 */
public class Test {
    public static void main(String[] args) {

        final List<String> list = new ArrayList<>();
        list.add("hello");
        list.add(" world");

        final int[] array = new int[3];
        array[0] = 0;
        array[1] = 1;
        array[2] = 3;

        final Map<String, Date> map = new HashMap<>();
        map.put("date", new Date());

        Map<String, Object> env = new HashMap<>();
        env.put("list", list);
        env.put("array", array);
        env.put("map", map);

        System.out.println(AviatorEvaluator.execute(
                "list[0]+':'+array[0]+':'+'today is '+map.date", env));

    }

}
```

（5） 三元比较符



```dart
/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/25
 */
public class Test {
    public static void main(String[] args) {

        Map<String, Object> env = new HashMap<String, Object>();
        env.put("a", -5);
        String result = (String) AviatorEvaluator.execute("a>0? 'yes':'no'", env);
        System.out.println(result);
    }

}
```

(6) 正则表达式匹配



```dart
/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/25
 */
public class Test {
    public static void main(String[] args) {
        String email = "hello2018@gmail.com";
        Map<String, Object> env = new HashMap<String, Object>();
        env.put("email", email);
        String username = (String) AviatorEvaluator.execute("email=~/([\\w0-8]+)@\\w+[\\.\\w+]+/ ? $1 : 'unknow' ", env);
        System.out.println(username);
    }
}
```

(7) 变量的语法糖衣



```csharp
/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/25
 */
public class Test {
    public static void main(String[] args) {
        User user = new User(1,"jack","18");
        Map<String, Object> env = new HashMap<>();
        env.put("user", user);

        String result = (String) AviatorEvaluator.execute(" '[user id='+ user.id + ',name='+user.name + ',age=' +user.age +']' ", env);
        System.out.println(result);
    }
}


/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/25
 */
public class User {

    private int id;

    private String name;

    private String age;

    public User() {
    }

    public User(int id, String name, String age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age='" + age + '\'' +
                '}';
    }

}
```

(8) nil对象[任何对象都比nil大除了nil本身]



```go
nil是Aviator内置的常量，类似java中的null，表示空的值。nil跟null不同的在
于，在java中null只能使用在==、!=的比较运算符，而nil还可以使用>、>=、
<、<=等比较运算符。Aviator规定，[任何对象都比nil大除了nil本身]。用户传入
的变量如果为null，将自动以nil替代。

        AviatorEvaluator.execute("nil == nil");  //true 
        AviatorEvaluator.execute(" 3> nil");    //true 
        AviatorEvaluator.execute(" true!= nil");    //true 
        AviatorEvaluator.execute(" ' '>nil ");  //true 
        AviatorEvaluator.execute(" a==nil ");   //true,a is null
nil与String相加的时候，跟java一样显示为null
```

(9) 日期比较



```swift
/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/25
 */
public class Test {
    public static void main(String[] args) {
        Map<String, Object> env = new HashMap<String, Object>();
        final Date date = new Date();
        String dateStr = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS").format(date);
        env.put("date", date);
        env.put("dateStr", dateStr);

        Boolean result = (Boolean) AviatorEvaluator.execute("date==dateStr",
 env);
        System.out.println(result);

        result = (Boolean) AviatorEvaluator.execute("date > '2009-12-20 
00:00:00:00' ", env);
        System.out.println(result);

        result = (Boolean) AviatorEvaluator.execute("date < '2200-12-20 
00:00:00:00' ", env);
        System.out.println(result);

        result = (Boolean) AviatorEvaluator.execute("date ==date ", env);
        System.out.println(result);


    }
}
```

(10) 语法手册

###### 数据类型

- Number类型：数字类型，支持两种类型，分别对应Java的Long和Double，也就是说任何整数都将被转换为Long，而任何浮点数都将被转换为Double，包括用户传入的数值也是如此转换。不支持科学计数法，仅支持十进制。如-1、100、2.3等。
- String类型： 字符串类型，单引号或者双引号括起来的文本串，如'hello world'，变量如果传入的是String或者Character也将转为String类型。
- Bool类型： 常量true和false，表示真值和假值，与java的Boolean.TRUE和Boolean.False对应。
- Pattern类型： 类似Ruby、perl的正则表达式，以//括起来的字符串，如//d+/，内部实现为java.util.Pattern。
- 变量类型： 与Java的变量命名规则相同，变量的值由用户传入，如"a"、"*b"等*
- nil类型: 常量nil,类似java中的null，但是nil比较特殊，nil不仅可以参与==、!=的比较，也可以参与>、>=、<、<=的比较，Aviator规定任何类型都n大于nil除了nil本身，nil==nil返回true。用户传入的变量值如果为null，那么也将作为nil处理，nil打印为null。

###### 算术运算符

Aviator支持常见的算术运算符，包括+ - <tt>* / % 五个二元运算符，和一元运算符"-"。其中 - `*`</tt> / %和一元的"-"仅能作用于Number类型。

"+"不仅能用于Number类型，还可以用于String的相加，或者字符串与其他对象的相加。Aviator规定，任何类型与String相加，结果为String。

###### 逻辑运算符

Avaitor的支持的逻辑运算符包括，一元否定运算符"!"，以及逻辑与的"&&"，逻辑或的"||"。逻辑运算符的操作数只能为Boolean。

###### 关系运算符

Aviator支持的关系运算符包括"<" "<=" ">" ">=" 以及"=="和"!=" 。
&&和||都执行短路规则。

关系运算符可以作用于Number之间、String之间、Pattern之间、Boolean之间、变量之间以及其他类型与nil之间的关系比较，不同类型除了nil之外不能相互比较。

Aviator规定任何对象都比nil大除了nil之外。

###### 匹配运算符

匹配运算符"=~"用于String和Pattern的匹配，它的左操作数必须为String，右操作数必须为Pattern。匹配成功后，Pattern的分组将存于变量$num，num为分组索引。

###### 三元运算符

Aviator没有提供if else语句，但是提供了三元运算符 "?:"，形式为 bool ? exp1: exp2。 其中bool必须为结果为Boolean类型的表达式，而exp1和exp2可以为任何合法的Aviator表达式，并且不要求exp1和exp2返回的结果类型一致。

1. 两种模式
   默认AviatorEvaluator以编译速度优先：
   AviatorEvaluator.setOptimize(AviatorEvaluator.COMPILE);
   你可以修改为运行速度优先，这会做更多的编译优化：
   AviatorEvaluator.setOptimize(AviatorEvaluator.EVAL);

------

#### 三.MVEL表达式解析器

1.简介 ：



```undefined
MVEL在很大程度上受到Java语法的启发，作为一个表达式语言，也有一些根本
的区别，旨在更高的效率，例如：直接支持集合、数组和字符串匹配等操作以
及正则表达式。 MVEL用于执行使用Java语法编写的表达式。
```

2.特性：



```dart
MVEL是一个功能强大的基于Java应用程序的表达式语言。
目前最新的版本是2.0，具有以下特性：
(1). 动态JIT优化器。当负载超过一个确保代码产生的阈值时，选择性地产生字
节代码,这大大减少了内存的使用量。新的静态类型检查和属性支持，允许集成
类型安全表达。
(2). 错误报告的改善。包括行和列的错误信息。
(3). 新的脚本语言特征。MVEL2.0 包含函数定义，如：闭包，lambda定义，
标准循环构造(for, while, do-while, do-until…)，空值安全导航操作，内联with
-context运营 ，易变的（isdef）的测试运营等等。
(4). 改进的集成功能。迎合主流的需求，MVEL2.0支持基础类型的个性化属性处理器，集成到JIT中。
(5). 更快的模板引擎，支持线性模板定义，宏定义和个性化标记定义。
(6). 新的交互式shell（MVELSH）。

(7). 缺少可选类型安全
(8). 集成不良，通常通过映射填入内容。没有字节码不能运作用字节码生成编
译时间慢，还增加了可扩展性问题；不用字节码生成运行时执行非常慢
(9). 内存消耗过大
(10). Jar巨大/依赖规模
```

3.原理：



```undefined
与java不同，MVEL是动态类型（带有可选分类），也就是说在源文件中是没有
类型限制的。一条MVEL表达式，简单的可以是单个标识符，复杂的则可能是
一个充满了方法调用和内部集合创建的庞大的布尔表达式。
```

4.使用方式：
maven引入jar：



```xml
<dependency>
            <groupId>org.mvel</groupId>
            <artifactId>mvel2</artifactId>
            <version>2.3.1.Final</version>
        </dependency>
```

测试：



```dart
package com.lrq.wechatdemo.utils;

import com.google.common.collect.Maps;
import org.mvel2.MVEL;

import java.util.Map;

/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/26
 */
public class MvelUtils {

    public static void main(String[] args) {
        String expression = "a == null && b == nil ";
        Map<String,Object> map = Maps.newHashMap();
        map.put("a",null);
        map.put("b",null);

        Object object = MVEL.eval(expression,map);
        System.out.println(object);
    }

}
```

------

#### 四.EasyRules规则引擎

1.简介：



```undefined
easy-rules首先集成了mvel表达式，后续可能集成SpEL的一款轻量
级规则引擎
```

2.特性：



```css
easy rules是一个简单而强大的java规则引擎，它有以下特性：

轻量级框架，学习成本低
基于POJO
为定义业务引擎提供有用的抽象和简便的应用
从原始的规则组合成复杂的规则
它主要包括几个主要的类或接口：Rule,RulesEngine,RuleListener,Facts 
还有几个主要的注解：@Action,@Condition,@Fact,@Priority,@Rule
```

3.使用方式：



```dart
@Rule可以标注name和description属性，每个rule的name要唯一，
如果没有指定，则RuleProxy则默认取类名
@Condition是条件判断，要求返回boolean值，表示是否满足条件

@Action标注条件成立之后触发的方法

@Priority标注该rule的优先级，默认是Integer.MAX_VALUE - 1，值
越小越优先

@Fact 我们要注意Facts的使用。Facts的用法很像Map，它是客户
端和规则文件之间通信的桥梁。在客户端使用put方法向Facts中添
加数据，在规则文件中通过key来得到相应的数据。
```

有两种使用方式：

1. java方式
   首先先创建规则并标注属性



```kotlin
package com.lrq.wechatdemo.rules;

import org.jeasy.rules.annotation.Action;
import org.jeasy.rules.annotation.Condition;
import org.jeasy.rules.annotation.Fact;
import org.jeasy.rules.annotation.Rule;
import org.jeasy.rules.support.UnitRuleGroup;

/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/26
 */
public class RuleClass {

    @Rule(priority = 1) //规则设定优先级
    public static class FizzRule {
        @Condition
        public boolean isFizz(@Fact("number") Integer number) {
            return number % 5 == 0;
        }

        @Action
        public void printFizz() {
            System.out.print("fizz\n");
        }
    }

    @Rule(priority = 2)
    public static class BuzzRule {
        @Condition
        public boolean isBuzz(@Fact("number") Integer number) {
            return number % 7 == 0;
        }

        @Action
        public void printBuzz() {
            System.out.print("buzz\n");
        }
    }

    public static class FizzBuzzRule extends UnitRuleGroup {

        public FizzBuzzRule(Object... rules) {
            for (Object rule : rules) {
                addRule(rule);
            }
        }

        @Override
        public int getPriority() {
            return 0;
        }
    }

    @Rule(priority = 3)
    public static class NonFizzBuzzRule {

        @Condition
        public boolean isNotFizzNorBuzz(@Fact("number") Integer number) {
            // can return true, because this is the latest rule to trigger according to
            // assigned priorities
            // and in which case, the number is not fizz nor buzz
            return number % 5 != 0 || number % 7 != 0;
        }

        @Action
        public void printInput(@Fact("number") Integer number) {
            System.out.print(number+"\n");
        }
    }

}
```

然后客户端调用



```cpp
package com.lrq.wechatdemo.rules;

import org.jeasy.rules.api.Facts;
import org.jeasy.rules.api.Rules;
import org.jeasy.rules.api.RulesEngine;
import org.jeasy.rules.core.DefaultRulesEngine;
import org.jeasy.rules.core.RulesEngineParameters;

/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/26
 */
public class RuleJavaClient {
    public static void main(String[] args) {
        // 创建规则引擎
        RulesEngineParameters parameters = new RulesEngineParameters().skipOnFirstAppliedRule(true);
        RulesEngine fizzBuzzEngine = new DefaultRulesEngine(parameters);

        // 创建规则集并注册规则
        Rules rules = new Rules();
        rules.register(new RuleClass.FizzRule());
        rules.register(new RuleClass.BuzzRule());
        rules.register(new RuleClass.FizzBuzzRule(new RuleClass.FizzRule(), new RuleClass.BuzzRule()));
        rules.register(new RuleClass.NonFizzBuzzRule());

        // 执行规则
        Facts facts = new Facts();
        for (int i = 1; i <= 100; i++) {
            facts.put("number", i);
            fizzBuzzEngine.fire(rules, facts);
            System.out.println();
        }
    }

}
```

2.yml方式

resources目录下新建fizzbuzz.yml



```bash
---
name: "fizz rule"
description: "print fizz if the number is multiple of 5"
priority: 1
condition: "number % 5 == 0"
actions:
- "System.out.println(\"fizz\")"

---
name: "buzz rule"
description: "print buzz if the number is multiple of 7"
priority: 2
condition: "number % 7 == 0"
actions:
- "System.out.println(\"buzz\")"

---
name: "fizzbuzz rule"
description: "print fizzbuzz if the number is multiple of 5 and 7"
priority: 0
condition: "number % 5 == 0 && number % 7 == 0"
actions:
- "System.out.println(\"fizzbuzz\")"

---
name: "non fizzbuzz rule"
description: "print the number itself otherwise"
priority: 3
condition: "number % 5 != 0 || number % 7 != 0"
actions:
- "System.out.println(number)"
```

客户端调用：



```swift
package com.lrq.wechatdemo.rules;

import org.jeasy.rules.api.Facts;
import org.jeasy.rules.api.Rules;
import org.jeasy.rules.api.RulesEngine;
import org.jeasy.rules.core.DefaultRulesEngine;
import org.jeasy.rules.core.RulesEngineParameters;
import org.jeasy.rules.mvel.MVELRuleFactory;

import java.io.FileNotFoundException;
import java.io.FileReader;

/**
 * CreateBy: haleyliu
 * CreateDate: 2018/12/26
 */
public class RuleYmlClient {

    public static void main(String[] args) throws FileNotFoundException {
        // create a rules engine
        RulesEngineParameters parameters = new RulesEngineParameters().skipOnFirstAppliedRule(true);
        RulesEngine fizzBuzzEngine = new DefaultRulesEngine(parameters);

        // create rules
        Rules rules = MVELRuleFactory.createRulesFrom(new FileReader("fizzbuzz.yml"));

        // fire rules
        Facts facts = new Facts();
        for (int i = 1; i <= 100; i++) {
            facts.put("number", i);
            fizzBuzzEngine.fire(rules, facts);
            System.out.println();
        }
    }
}
```

## 前言

在很多企业的 IT 业务系统中，经常会有大量的业务规则配置，而且随着企业管理者的决策变化，这些业务规则也会随之发生更改。为了适应这样的需求，我们的 IT 业务系统应该能快速且低成本的更新。适应这样的需求，一般的作法是将业务规则的配置单独拿出来，使之与业务系统保持低耦合。目前，实现这样的功能的程序，已经被开发成为规则引擎。

规则引擎是一种推理引擎，它是根据已有的事实，从规则知识库中匹配规则，并处理存在冲突的规则，执行最后筛选通过的规则。因此，规则引擎是人工智能（AI）研究领域的一部分，具有一定的选择判断性、人工智能性和富含知识性。目前，比较流行的规则引擎有商业规则引擎 iLog 和开源规则引擎 drools。本文将对开源规则引擎 drools 做详细介绍，并通过分析一个在汽车保险行业中的实际应用案例，让读者对开源规则流引擎有一个更深刻的理解。

## 1. 基于 rete 算法的规则引擎

在 AI 领域，产生式系统是一个很重要的理论，产生式推理分为正向推理和逆向推理产生式，其规则的一般形式是：IF 条件 THEN 操作。rete 算法是实现产生式系统中正向推理的高效模式匹配算法，通过形成一个 rete 网络进行模式匹配，利用基于规则的系统的时间冗余性和结构相似性特征 [8]，提高系统模式匹配效率。本文将介绍的 Drools 引擎就是利用 rete 算法对规则进行分析，形成 rete 网络，对模式进行匹配。

### 1.1 rete 算法研究

**1.1.1 rete 算法概述**

Rete 算法最初是由卡内基梅隆大学的 Charles L.Forgy 博士在 1974 年发表的论文中所阐述的算法 , 该算法提供了专家系统的一个高效实现。自 Rete 算法提出以后 , 它就被用到一些大型的规则系统中 , 像 ILog、Jess、JBoss Rules 等都是基于 RETE 算法的规则引擎 [7]。

Rete 在拉丁语中译为”net”，即网络。Rete 匹配算法是一种进行大量模式集合和大量对象集合间比较的高效方法，通过网络筛选的方法找出所有匹配各个模式的对象和规则。

其核心思想是将分离的匹配项根据内容动态构造匹配树，以达到显著降低计算量的效果。Rete 算法可以被分为两个部分：规则编译和规则执行 [7]。当 Rete 算法进行事实的断言时，包含三个阶段：匹配、选择和执行，称做 match-select-act cycle。

**1.1.2 rete 算法相关概念**

Rete 算法规则相关的概念有如下几个：

Fact：已经存在的事实，它是指对象之间及对象属性之间的多元关系，为简单起见，事实用一个三元组来表示：（标识符 ^ 属性 值）[1]，例如如下事实：

w1:(B1 ^ on B2) w6:(B2 ^color blue)
w2:(B1 ^ on B3) w7:(B3 ^left-of B4)
w3:(B1 ^ color red) w8:(B3 ^on table)
w4:(B2 ^on table) w9:(B3 ^color red)
w5:(B2 ^left-of B3)

Rule：规则，包含条件和行为两部分，条件部分又叫左手元（LHS），行为部分又叫右手元（RHS）。条件部分可以有多条条件，并且可以用 and 或 or 连接 [1]。其一般形式如下：

| 123456789101112131415161718 | (name-of-this-production LHS /*one or more conditions*/ --> RHS /*one or more actions*/ )例如，下面的例子： (find-stack-of-two-blocks-to-the-left-of-a-red-block (^on) (^left-of) (^color red) --> ...RHS... ) Patten：模式，也就是规则的条件部分，是已知事实的泛化形式，是未实例化的多元关系 <sup>[1]</sup>。比如，前面的那条规则的条件部分： (^on) (^left-of) (^color red) Rete 网络的概念 <sup>[1][9][10]</sup>如下： |
| --------------------------- | ------------------------------------------------------------ |
|                             |                                                              |

RootNode：Rete 网络的根节点，所有对象通过 Root 节点进入网络。

ObjectTypeNode：对象类型节点，保证所传入的对象只会进入自己类型所在的网络，提高了工作效率。

AlphaNode：Alpha 节点是规则的条件部分的一个模式，一个对象只有和本节点匹配成功后，才能继续向下传播。

JoinNode：用作连接（jion）操作的节点，相当于 and，相当于数据库的表连接操作，属于 betaNode 类型的节点。BetaNode 节点用于比较两个对象和它们的字段。两个对象可能是相同或不同的类型。我们将这两个输入称为左和右。BetaNode 的左输入通常是一组对象的数组。BetaNode 具有记忆功能。左边的输入被称为 Beta Memory，会记住所有到达过的语义。右边的输入成为 Alpha Memory，会记住所有到达过的对象。

NotNode：根据右边输入对左边输入的对象数组进行过滤，两个 NotNode 可以完成‘ exists ’检查。

LeftInputAdapterNodes：将单个对象转化成对象数组。

Terminal Nodes 被用来表明一条规则已经匹配了它的所有条件（conditions）。

图 1 展示的是一个简单的 rete 网络：

图 1. RETE 网络

![图 1. RETE 网络](https://www.ibm.com/developerworks/cn/opensource/os-drools/image001.png)

**1.1.3 创建 rete 网络**

Rete 算法的编译结果是创建了规则集对应的 Rete 网络 , 它是一个事实可以在其中流动的图。创建 rete 网络的过程 [1]如下： 1) 创建根节点； 2) 加入一条规则 1 (Alpha 节点从 1 开始，Beta 节点从 2 开始 )； a. 取出规则中的一个模式 1，检查模式中的参数类型，如果是新类型，则加入一个类型节点； b. 检查模式 1 对应的 Alpha 节点是否已存在，如果存在则记录下节点位置，如果没有则将模式 1 作为一个 Alpha 节点加入到网络中，同时根据 Alpha 节点的模式建立 Alpha 内存表； c. 重复 b 直到所有的模式处理完毕； d. 组合 Beta 节点，按照如下方式： Beta(2) 左输入节点为 Alpha(1)，右输入节点为 Alpha(2) Beta(i) 左输入节点为 Beta(i-1)，右输入节点为 Alpha(i) i>2 并将两个父节点的内存表内联成为自己的内存表； e. 重复 d 直到所有的 Beta 节点处理完毕； f. 将动作（Then 部分）封装成叶节点（Action 节点）作为 Beta(n) 的输出节点； 3) 重复 2) 直到所有规则处理完毕； 执行完上述步骤，建立的 rete 网络如下图 2 (a 图为含有 3 个规则的 rete 网络，b 图为含有一个规则的 rete 网络 )：

图 2. beta-network and alpha-network

![图 2. beta-network and alpha-network](https://www.ibm.com/developerworks/cn/opensource/os-drools/image002.png)

上图（a 图和 b 图），他们的左边的部分都是 beta-network, 右边都是 alpha-network, 圆圈是 join-node。右边的 alpha-network 是根据事实库和规则条件构建的，其中除 alpha-network 节点的节点都是根据每一条规则条件的模式 , 从事实库中 match 过来的，即在编译构建网络的过程中静态建立的。只要事实库是稳定的，RETE 算法的执行效率应该是非常高的，其原因就是已经通过静态的编译，构建了 alpha-network。左边的 beta-network 表现出了 rules 的内容，其中 p1,p2,p3 共享了许多 BetaMemory 和 join-node, 这样能加快匹配速度。

**1.1.4 Rete 算法的匹配过程**

匹配过程如下： 1) 对于每个事实，通过 select 操作进行过滤，使事实沿着 rete 网达到合适的 alpha 节点。2) 对于收到的每一个事实的 alpha 节点，用 Project( 投影操作 ) 将那些适当的变量绑定分离出来。使各个新的变量绑定集沿 rete 网到达适当的 bete 节点。3) 对于收到新的变量绑定的 beta 节点，使用 Project 操作产生新的绑定集，使这些新的变量绑定沿 rete 网络至下一个 beta 节点以至最后的 Project。4) 对于每条规则，用 project 操作将结论实例化所需的绑定分离出来。

如果把 rete 算法类比到关系型数据库操作，则事实集合就是一个关系，每条规则就是一个查询，再将每个事实绑定到每个模式上的操作看作一个 Select 操作，记一条规则为 P，规则中的模式为 c1,c2,…,ci, Select 操作的结果记为 r(ci), 则规则 P 的匹配即为 r(c1)◇r(c2)◇…◇(rci)。其中◇表示关系的连接（Join）操作。

Rete 网络的连接（Join）和投影 (Project) 和对数据库的操作形象对比如图 3 所示：

图 3. join and project

![图 3. join and project](https://www.ibm.com/developerworks/cn/opensource/os-drools/image003.png)

**1.1.5 Rete 算法的特点、不足和建议 Rete 算法有如下特点：**

a． Rete 算法是一种启发式算法，不同规则之间往往含有相同的模式，因此在 beta-network 中可以共享 BetaMemory 和 betanode。如果某个 betanode 被 N 条规则共享，则算法在此节点上效率会提高 N 倍。

b. Rete 算法由于采用 AlphaMemory 和 BetaMemory 来存储事实，当事实集合变化不大时，保存在 alpha 和 beta 节点中的状态不需要太多变化，避免了大量的重复计算，提高了匹配效率。

c. 从 Rete 网络可以看出，Rete 匹配速度与规则数目无关，这是因为事实只有满足本节点才会继续向下沿网络传递。

Rete 算法的不足：

a. 事实的删除与事实的添加顺序相同, 除了要执行与事实添加相同的计算外, 还需要执行查找, 开销很高 [3]。

b. RETE 算法使用了β存储区存储已计算的中间结果, 以牺牲空间换取时间, 从而加快系统的速度。然而β存储区根据规则的条件与事实的数目而成指数级增长, 所以当规则与事实很多时, 会耗尽系统资源 [3]。

针对 Rete 算法的特点和不足，在应用或者开发基于 Rete 算法的规则引擎时，提出如下建议：

a. 容易变化的规则尽量置后匹配，可以减少规则的变化带来规则库的变化。

b. 约束性较为通用或较强的模式尽量置前匹配，可以避免不必要的匹配。

c. 针对 Rete 算法内存开销大和事实增加删除影响效率的问题，技术上应该在 alpha 内存和 beata 内存中，只存储指向内存的指针，并对指针建里索引（可用 hash 表或者非平衡二叉树）。

d. Rete 算法 JoinNode 可以扩展为 AndJoinNode 和 OrJoinNode，两种节点可以再进行组合 [5]。

### 1.2 基于 Rete 算法的 drools 开源规则引擎

**1.2.1 Drools 规则引擎简介**

Drools 具有一个易于访问企业策略、易于调整以及易于管理的开源业务 [规则引擎](http://baike.baidu.com/view/1636209.htm)，符合业内标准，速度快、效率高。业务分析师或审核人员可以利用它轻松查看业务规则，从而检验已编码的规则是否执行了所需的业务规则。其前身是 Codehaus 的一个开源项目叫 Drools，最近被纳入 JBoss 门下，更名为 JBoss Rules，成为了 JBoss 应用服务器的规则引擎。

Drools 被分为两个主要的部分：编译和运行时。编译是将规则描述文件按 ANTLR 3 语法进行解析，对语法进行正确性的检查，然后产生一种中间结构“descr”，descr 用 AST 来描述规则。目前，Drools 支持四种规则描述文件，分别是：drl 文件、 xls 文件、brl 文件和 dsl 文件，其中，常用的描述文件是 drl 文件和 xls 文件，而 xls 文件更易于维护，更直观，更为被业务人员所理解。运行时是将 AST传到 PackageBuilder，由 PackagBuilder来产生 RuleBase，它包含了一个或多个 Package 对象。

Drools 的语法规则将在实践中介绍，下面分析 drools 的原理。

**1.2.2 Drools 规则引擎原理**

Drools 中的 Rete 算法被称为 ReteOO，表示 Drools 为面向对象系统（Object Oriented systems）增强并优化了 Rete 算法。

在 Drools 中，规则被存 放在 Production Memory（规则库）中，推理机要匹配的 facts（事实）被存在 Working Memory（工作内存）中。当时事实被插入到工作内存中后，规则引擎会把事实和规则库里的模式进行匹配，对于匹配成功的规则再由 Agenda 负责具体执行推理算法中被激发规则的结论部分，同时 Agenda 通过冲突决策策略管理这些冲突规则的执行顺序，Drools 中规则冲突决策策略有：(1) 优先级策略 (2) 复杂度优先策略 (3) 简单性优先策略 (4) 广度策略 (5) 深度策略 (6) 装载序号策略 (7) 随机策略 [5][6]。

图 4. Drools 的原理示意图

![图 4. Drools 的原理示意图](https://www.ibm.com/developerworks/cn/opensource/os-drools/image004.png)

## 2. 应用实践

### 2.1 需求描述

在汽车保险行业中，每个地区都会有自己的车险投保规则，而且这些投保规则会经常变动，为适应这样的业务需求，可以采用 drools 开源规则引擎。 在本文介绍的例子中，具体业务需求是：应用应该能够根据前台传入的车辆信息和地区信息，从车辆和套餐的关系配置中匹配这辆车可用的套餐；然后，根据从套餐配置中获取套餐信息，套餐信息中包含了该套餐可用的险别（如车损险、乘客责任和盗抢险诸如之类的称之为险别）；最后从险别配置中获取险别信息。

### 2.2 需求分析

由于每个地区的规则不一样，所以要对规则进行分组，每个地区的车辆和套餐的关系配置和套餐配置要分别在不同的文件中，而险别是不变信息，各个地区用同一个险别配置。车辆和套餐的关系配置放在一个 RuelTable 中，套餐配置放在另一个 RuelTable 中，这两个 RuelTable 在用一个 xls 文件中描述即可。

这样配置后，每次引擎先根据地区代码执行相应的规则文件；进入规则文件后，再根据车辆信息过滤套餐找出适合这辆车的套餐，然后更新传入的对象，这时会重新匹配规则（已经匹配过的不应该再匹配，后面代码中会介绍）；然后再匹配套餐，匹配后，更新对象；最后进入险别对应的文件匹配险别。

### 2.3 代码实践

首先，建立 Drools BRMS 应用。Drools BRMS 是一个管理和编译规则和规则流的 Web 应用程序，可以部署在大部分的支持 J2SE 1.5 的 Web 容器下，如 Tomcat6。Drools BRMS 架构体系分为三大部分，第一部分是 UI 层，提供了一个基于 Ajax 技术的业务规则编辑、管理工具。第二部分是规则文件仓库层，将规则文件统一保持在文件系统或关系数据库。最后一个是 Drools 的核心引擎，用来对用户提交的规则文件进行验证、编译和部署。开发人员通过规则文件的编辑部署，生成了包含 rule 的 package 对象，这是引擎可直接操作的内存对象。BRMS 通过一个 URL 提供对这个对象的 HTTP 访问。第三方可以通过 Agent 相关 API 来访问这个 URL，程序自动下载这个 Package 对象就直接可以在规则引擎运行，得到规则执行的结果。

然后，将 BOM(Business Object Model 业务规则引擎所要操作的对象 )、规则流文件（图 2-2 所对应的文件）和规则文件（图 2-3 和图 2-4 所对应的文件）上传到 BRMS 中。下面对各个文件进行介绍。

图 5 描述的是 BOM 对象，分别是 GeProposalInfo、GeCar、GeComboArea、GeCombo 和 GeKind，他们的关系从图中可以很明显的看出，这里不再赘述。

图 5. BOM 类

![图 5. BOM 类](https://www.ibm.com/developerworks/cn/opensource/os-drools/image005.png)

图 6 中，开始节点是表示流程的开始。在 diverge 分枝节点处按 GeComboArea 里的 AreaCode 属性值有四个分枝，这四个分枝按优先级只要有一个满足条件就继续向下执行。diverge 分枝节点有 And、Xor 和 Or 三种类型，其含义分别是执行所有分枝、执行按优先级首先符合条件的分枝、执行所有符合条件的分枝。RuleTask 规则任务节点对应的是这个 RuleGroup 规则组里的规则。执行完地区层次的规则后，进入 converge 聚合节点，此节点等待分枝节点中任何一个节点执行完毕后执行。converge 分枝节点有 And、Xor、n-of-m 和 Discriminator 四种类型，其含义分别是等待所有分枝执行完毕、按优先级只等待一个分枝执行完、等待一个分枝执行完，但每个分枝执行完后会导致继续等待下一个分枝执行和等待在 m 个分枝中有 n 个分枝执行完毕。规则任务节点 Rule_Kind 是执行 Rule_Kind 规则组里的规则。结束节点标志着规则流执行完毕。

图 6. 规则流

![图 6. 规则流](https://www.ibm.com/developerworks/cn/opensource/os-drools/image006.png)

图 7 和图 8 分别是 beijing.xls 和 kind.xls 的截图。在决策表中，不同作用的表格用不同颜色区分。在黑色区中，有一个 RuleTable 关键词，它表示本决策表从这开始，解析的时候也就是从这按从上到下和从左到右的顺序开始解析，其后是表名称。CONDITION 是表明此列为条件的关键词。和并列中 pi:GeProposalInfo 的意思是从 workmemory 中选取类型为 GeProposalInfo 的一个对象赋值给 pi。car.carType matches ".*$param.*"的含义是查看 pi 中对象 car 中的 carType 属性值是否包含此列单元格中的值。".*$param.*"为正则表达式，$param 为对单元格中值的引用。Matches 是一个操作。RULEFLOW-GROUP 是对规则分组的关键字，它和规则任务节点对应。PRIORITY 设置规则执行优先级，数值越大越先被执行。ACTION 是规则的行为部分，可以在单元格中写 java 代码。另外，单元格中有内容表示执行匹配或执行 java 代码，没有内容表示什么都不做，跳过。

图 7. 规则表定义一

![图 7. 规则表定义一](https://www.ibm.com/developerworks/cn/opensource/os-drools/image007.png)

图 8. 规则表定义二

![图 8. 规则表定义二](https://www.ibm.com/developerworks/cn/opensource/os-drools/image008.png)

图 9 是 beijing.xls 和 kind.xls 里的规则生成的 rete 网络。在编写规则中，我们采用了本文的建议 a（将容易变化的规则尽量放后）和 b（将强约束条件放前），这样产生的 rete 网络匹配效率会更高。如图 2-5 中，在红色节点（类型节点）下会有对 updateFlag 的三个分枝，updateFlag 是强约束条件且不会变化太大，仅在此节点上，匹配效率就提高了三分之一。

图 9. 生成的 Rete 网络

![图 9. 生成的 Rete 网络](https://www.ibm.com/developerworks/cn/opensource/os-drools/image009.png)

最后，我们对我们的应用程序端的调用做一下阐述。

**第一步：创建规则库**

| 1234567891011121314151617 | KnowledgeBase kbase = readKnowledgeBase(); readKnowledgeBase 方法必须是单例方法，其内容如下： 创建 kbuilder 对象（用来编译规则的对象） KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();  Brms 应用程序上规则包（也就是规则库）所在 url 地址 String urlString = "http://localhost:8080/drools-5.1.1guvnor/org.drools.guvnor.Guvnor/package/combo";    URL url = new URL(urlString);    UrlResource urlResource = (UrlResource)ResourceFactory.newUrlResource(url); 只要设置采用基本授权就可登录 Brms    urlResource.setBasicAuthentication("enabled"); 将已经编译好的规则包加入 kbuilder 对象，此处加入的是 pkg 类型    kbuilder.add(urlResource, ResourceType.PKG); 创建 KnowledgeAgent（ruleaget 类是不稳定或实验中的代理类）代理，它负责维护与 brms 里的规则保持版本一致性    KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent("combo");    KnowledgeBase kbase = kagent.getKnowledgeBase(); 将规则包加入规则库    kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());    return kbase; |
| ------------------------- | ------------------------------------------------------------ |
|                           |                                                              |

**第二步：创建 workmemory 并插入对象**

| 1234567891011121314 | 创建 workmemory 对象 ksession StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession(); 设置初始值    GeComboArea ca = new GeComboArea();    ca.setAreaCode("010");    GeCar c=new GeCar();    c.setCarAge(9);    c.setCarPrice(15000);    c.setCarType("华晨 bmw11 年款");    GeProposalInfo pi=new GeProposalInfo();    pi.setCar(c);    pi.setComboArea(ca); 将 pi 插入 workmemory 中，此时会构建 rete 网络    ksession.insert(pi); |
| ------------------- | ------------------------------------------------------------ |
|                     |                                                              |

**第三步：执行规则流和规则**

| 1234 | 激活规则流 ksession.startProcess("com.sample.ruleflow"); 激活规则    ksession.fireAllRules(); |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

**第四步：释放资源**

| 1    | ksession.dispose(); |
| ---- | ------------------- |
|      |                     |

## 3. 总结

本文通过深入剖析 rete 算法和基于 rete 算法的规则引擎，发现了算法中存在的问题，提出了算法改进的意见，同时也阐述了在应用规则引擎时应该注意的问题，并通过实例对规则引擎进行了实践。

# [业务规则引擎浅析](https://www.cnblogs.com/jietang/p/5321841.html)

　　在CRM（客户关系管理）系统或者其他业务支撑型系统的开发过程中，最经常多变的就是复杂的业务规则。因为这些规则要迎合、顺应市场的变化，如何能有效到做到业务规则和整体的系统支撑架构解耦分离，这个是开发过程中必须考虑的一个问题。每当客户要求改变一个业务规则的时候，我们又如何能做到在最短的时间内完成需求的开发提交，提高系统的灵活度？业务规则引擎无非是一个比较好的解决方案。它把复杂、冗余的业务规则同整个支撑系统分离开，做到架构的可复用移植，这个就是我们的终极目标。

　　那规则引擎又是什么东西？严格来说，它是一种嵌入到应用程序中的一个组件，能很好的把业务决策从应用程序框架中分离出来，然后使用预定义的方言（dialect）编写语义模块和业务决策模块，使用约定好的语法规范，接受用户的输入，然后解析用户的业务规则，然后根据解析好的业务规则，作出业务决策。可以说，一个好的支撑系统，离不开一个灵活的业务规则引擎，在某种意义上可以做到“以不变应万变”。

　　言归正传，那既然业务规则引擎这么好？那要如何设计实现呢？写到这里，我忽然就想起我大学的时候，我的启蒙老师跟我说的一句话：我们可以不要重复发明轮子，但是要能很好的运用和理解如何使用别人造好的“轮子”。这句话一直是我的座右铭。现在就有一个开源的业务规则引擎Drools，就能很好的满足我们的要求。以此为基础，站在巨人的肩膀上，何乐而不为呢？

　　Drools是什么？

　　简单来说，Drools是基于Java的规则引擎框架，是JBoss开源社区中的一个为Java量身定制的、基于RETE算法的产生式规则引擎的实现。大致的工作原理是，基于XML、DRL（Drools规则配置文件）的基础上，通过一个内置的解析器，把业务规则翻译成AST（Abstract Syntax Tree），最终会映射编译成Java的代码包，然后在程序运行的时候，加载这些代码包中的业务规则，并把在工作内存空间的规则和事实进行匹配，看下事实是否符合业务规则的约定。

　　业务规则引擎的架构设计

　　主要从两方面考虑，把常用的业务规则脚本放置到数据库进行存储，后续为了节省程序的IO开销，可以通过缓存机制从数据库从增量拷贝业务规则的镜像，程序客户端直接同缓存打交道。目前基于Java可以考虑的缓存框架也有很多，比如JCS（Java Caching System）。另外一个方面如果一个系统是分布式架构，可以考虑通过Zookeeper上面的节点进行业务规则的分布式部署，也可以实现规则的灰度版本发布、业务规则的动态事件监控等等操作。同样的，程序客户端可以直接同Zookeeper的某个节点通信，获得业务规则的数据，Zookeeper本身也会自动同步数据库中的业务规则。综上所述，得到如下图所示的业务规则引擎架构

　　![img](https://images2015.cnblogs.com/blog/913759/201603/913759-20160326022150167-1148468795.jpg)

　　业务规则引擎主要包含如下模块

1. BusinessRuleExecutor 规则引擎配置执行器接口：主要用来定义获取业务规则配置的动作方式。
2. BusinessRuleExecutorImpl 规则引擎配置加载模块：实现了BusinessRuleExecutor接口，目前演示的是基于Oracle数据库，加载业务规则配置的动作方式。
3. BusinessRule 业务规则元素：定义业务规则的接口，主要包含：业务规则标识、业务规则内容。
4. BusinessRuleRunner 业务规则引擎执行器：主要是执行具体的业务规则脚本代码，触发相应的事件判断。

　　类图层次结构如下所示

　　![img](https://images2015.cnblogs.com/blog/913759/201603/913759-20160326022752948-1095084709.jpg)

　　现在我们就用一个实际的例子，配合上面的框架来进行一下讲解。

　　在移动业务支撑型系统中，为了留住更多的在网移动用户，业务规定，凡是现有用户中，有订购家庭产品和VPN产品，并且他是动感地带品牌的，都认为是移动的幸运用户。如果我们遇到这种业务规则，又应该如何来实现？

　　我们首先梳理一下业务类图实体结构：

　　我们发现，这里实际上有三个实体，一个是用户，一个是用户订购的产品，一个是幸运客户。并且一个用户是可以订购多个产品的，用户的品牌有动感地带，此外还有全球通。主要针对的产品是VPN产品（VPNPRODUCT）和家庭产品（FAIMILYPROUDCT），于是我们画出如下的类图结构：

　　![img](https://images2015.cnblogs.com/blog/913759/201603/913759-20160326023349308-1590055092.jpg)

　　现在理清楚了业务规则和潜在实体，我们现在来看下如何实现？

　　首先在数据库中，我们可以简单设计如下表结构进行规则存储，表结构如下所示（基于Oracle）

　　create table pms.ng_business_rule
　　(
　　　　rule_id number(4),
　　　　drl_content varchar2(1024)
　　);

　　其中rule_id表示规则编码，drl_content表示规则的内容，具体的JavaBean映射结构如下

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * @filename:BusinessRule.java
 *
 * Newland Co. Ltd. All rights reserved.
 * 
 * @Description:业务规则定义
 * @author tangjie
 * @version 1.0
 * 
 */

package newlandframework.ruleengine;

import java.io.Serializable;

public class BusinessRule implements Serializable {
    private Integer ruleId;
    private String drlContent;

    public Integer getRuleId() {
        return ruleId;
    }

    public void setRuleId(Integer ruleId) {
        this.ruleId = ruleId;
    }

    public String getDrlContent() {
        return drlContent;
    }

    public void setDrlContent(String drlContent) {
        this.drlContent = drlContent;
    }

    @Override
    public String toString() {
        return "BusinessRule{id:" + getRuleId() + "|rule:" + getDrlContent()
                + "}";
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　现在再来看下，规则引擎配置执行器接口定义的内容

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * @filename:BusinessRuleExecutor.java
 *
 * Newland Co. Ltd. All rights reserved.
 * 
 * @Description:规则引擎配置执行器接口定义
 * @author tangjie
 * @version 1.0
 * 
 */

package newlandframework.ruleengine;

import java.util.List;

public interface BusinessRuleExecutor {
    List<BusinessRule> findAll();
    List<BusinessRule> findAllByRuleId(Integer ruleId);
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　然后是基于Oracle数据库加载业务规则配置模块，当然你还可以继续实现BusinessRuleExecutor接口的方法，完成缓存读取、Zookeeper方式读取业务规则的相应模块，这里就不再复述实现细节，后续有时间可以补上。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * @filename:BusinessRuleExecutorImpl.java
 *
 * Newland Co. Ltd. All rights reserved.
 * 
 * @Description:规则引擎配置加载模块（DB方式）
 * @author tangjie
 * @version 1.0
 * 
 */

package newlandframework.ruleengine;

import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport;
import org.springframework.jdbc.core.simple.ParameterizedBeanPropertyRowMapper;

import java.util.List;
import java.util.Map;

public class BusinessRuleExecutorImpl extends NamedParameterJdbcDaoSupport
        implements BusinessRuleExecutor {

    private static final RowMapper<BusinessRule> ruleMapper = ParameterizedBeanPropertyRowMapper.newInstance(BusinessRule.class);

    private Map<String, String> ruleList;

    protected String getRuleList(String key) {
        return (ruleList != null) ? ruleList.get(key) : null;
    }

    public void setRuleList(Map<String, String> ruleList) {
        this.ruleList = ruleList;
    }

    protected <T> List<T> query(String queryId, RowMapper<T> rowMapper, Object... args) {
        return getJdbcTemplate().query(getRuleList(queryId), rowMapper, args);
    }

    public List<BusinessRule> findAll() {
        return query("select-rule", ruleMapper);
    }

    public List<BusinessRule> findAllByRuleId(Integer ruleId) {
        return query("select-rule-by-id", ruleMapper, ruleId);
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　接下来就是关键的模块，业务规则引擎执行器，是基于Drools的实现，drlContent是指业务规则的内容，elements是指业务规则中关注的事实对象。具体代码如下

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 * @filename:BusinessRuleRunner.java
 *
 * Newland Co. Ltd. All rights reserved.
 * 
 * @Description:业务规则引擎执行器
 * @author tangjie
 * @version 1.0
 * 
 */

package newlandframework.ruleengine;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;

import org.drools.builder.ResourceType;
import org.drools.definition.KnowledgePackage;
import org.drools.io.ResourceFactory;
import org.drools.runtime.StatefulKnowledgeSession;
import org.drools.KnowledgeBase;
import org.drools.KnowledgeBaseFactory;
import org.drools.builder.KnowledgeBuilder;
import org.drools.builder.KnowledgeBuilderFactory;

public class BusinessRuleRunner {

    public BusinessRuleRunner() {}
    
    public void notify(String drlContent, ArrayList<Object> elements) {

        //构建知识库引擎
        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
        
        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

        try {
            kbuilder.add(ResourceFactory.newInputStreamResource(getDrlStream(drlContent)), ResourceType.DRL);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        Collection<KnowledgePackage> pkgs = kbuilder.getKnowledgePackages();
        kbase.addKnowledgePackages(pkgs);
        
        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
        
        //drl脚本有编译问题要提示
        if (kbuilder.hasErrors()) {
            System.out.println(kbuilder.getErrors().toString());
            throw new RuntimeException("Unable to compile: " + drlContent+ "\n");
        }
        
        //插入WorkingMemory
        for (int i = 0; i < elements.size(); i++) {
            Object fact = elements.get(i);
            ksession.insert(fact);
        }

        //激活规则
        ksession.fireAllRules();
    }
    
    private InputStream getDrlStream(String drlContent) throws Exception{  
        ByteArrayInputStream is = new ByteArrayInputStream(drlContent.getBytes());  
        return is;  
    }  
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　然后用Spring框架实现业务规则配置的自动装配，首先是business-rule-config-spring.xml

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="location" value="newlandframework/ruleengine/db.properties" />
    </bean>
    <bean id="dataSource"
        class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="${jdbc.driverClassName}" />
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
    </bean>
    <bean id="ruleengine-config" class="newlandframework.ruleengine.BusinessRuleExecutorImpl">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="ruleList">
            <map>
                <entry key="select-rule">
                    <value><![CDATA[
              select rule_id,drl_content from ng_business_rule
            ]]></value>
                </entry>
                <entry key="select-rule-by-id">
                    <value><![CDATA[
              select rule_id,drl_content from ng_business_rule where rule_id = ?
            ]]></value>
                </entry>
            </map>
        </property>
    </bean>
</beans>
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　数据库方式实现业务规则配置读取的事务控制Spring配置：business-rule-spring.xml

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx-3.1.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-3.1.xsd">    <import resource="business-rule-config-spring.xml" />
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>
    <aop:config>
        <aop:pointcut id="servicePointcut" expression="execution(* newlandframework.ruleengine.*.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="servicePointcut"/>
    </aop:config>
</beans>
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　再看下用户、用户产品、幸运用户的实体类定义

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package newlandframework.ruleengine;

/**
 * @filename:Users.java
 *
 * Newland Co. Ltd. All rights reserved.
 * 
 * @Description:用户定义
 * @author tangjie
 * @version 1.0
 * 
 */

import java.util.List;

public class Users {
    // 全球通品牌
    public static final Integer GOTONE = 1000;
    // 动感地带品牌
    public static final Integer MZONE = 1016;

    // 用户归属地市编码(591表示福州/592表示厦门)
    private Integer homeCity;
    // 用户的手机号码
    private Integer msisdn;
    // 用户标识
    private Integer userId;
    // 用户品牌标识
    private Integer userBrand;

    private List<UserProduct> userProduct;

    public List<UserProduct> getUserProduct() {
        return userProduct;
    }

    public void setUserProduct(List<UserProduct> userProduct) {
        this.userProduct = userProduct;
    }

    public Integer getHomeCity() {
        return homeCity;
    }

    public void setHomeCity(Integer homeCity) {
        this.homeCity = homeCity;
    }

    public Integer getMsisdn() {
        return msisdn;
    }

    public void setMsisdn(Integer msisdn) {
        this.msisdn = msisdn;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    public Integer getUserBrand() {
        return userBrand;
    }

    public void setUserBrand(Integer userBrand) {
        this.userBrand = userBrand;
    }

    @Override
    public String toString() {
        return "Users [homeCity=" + homeCity + ", msisdn=" + msisdn
                + ", userId=" + userId + ", userBrand=" + userBrand
                + ", userProduct=" + userProduct + "]";
    }
}


/**
 * @filename:UserProduct.java
 *
 * Newland Co. Ltd. All rights reserved.
 * 
 * @Description:用户产品定义
 * @author tangjie
 * @version 1.0
 * 
 */

package newlandframework.ruleengine;

public class UserProduct {
    // VPN产品编码
    public static final Integer VPNPRODUCT = 1000000001;
    // 家庭产品编码
    public static final Integer FAIMILYPROUDCT = 1000000002;

    // 用户归属地市编码(591表示福州/592表示厦门)
    private Integer homeCity;
    // 用户标识
    private Integer userId;
    // 产品编码
    private Integer productId;
    // 产品名称描述
    private String productName;

    public Integer getHomeCity() {
        return homeCity;
    }

    public void setHomeCity(Integer homeCity) {
        this.homeCity = homeCity;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    public Integer getProductId() {
        return productId;
    }

    public void setProductId(Integer productId) {
        this.productId = productId;
    }

    public String getProductName() {
        return productName;
    }

    public void setProductName(String productName) {
        this.productName = productName;
    }

    @Override
    public String toString() {
        return "UserProduct [homeCity=" + homeCity + ", userId=" + userId
                + ", productId=" + productId + ", productName=" + productName
                + "]";
    }
}


/**
 * @filename:LuckUsers.java
 *
 * Newland Co. Ltd. All rights reserved.
 * 
 * @Description:幸运用户定义
 * @author tangjie
 * @version 1.0
 * 
 */

package newlandframework.ruleengine;

public class LuckUsers {
    // 用户归属地市编码(591表示福州/592表示厦门)
    private Integer homeCity;
    // 用户的手机号码
    private Integer msisdn;
    // 用户标识
    private Integer userId;

    public LuckUsers() {

    }

    public LuckUsers(Integer homeCity, Integer msisdn, Integer userId) {
        super();
        this.homeCity = homeCity;
        this.msisdn = msisdn;
        this.userId = userId;
    }

    public Integer getHomeCity() {
        return homeCity;
    }

    public void setHomeCity(Integer homeCity) {
        this.homeCity = homeCity;
    }

    public Integer getMsisdn() {
        return msisdn;
    }

    public void setMsisdn(Integer msisdn) {
        this.msisdn = msisdn;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public String toString() {
        return "LuckUsers [homeCity=" + homeCity + ", msisdn=" + msisdn
                + ", userId=" + userId + "]";
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
　　最后是Drools的业务规则配置的内容，我们把它入库到数据库表pms.ng_business_rule中的drl_content字段，其中规则标识可以用序列自动生成。
```

　　业务规则的主要逻辑就是判断这个用户是不是幸运用户？业务判断标准是：该用户订购了家庭产品和VPN产品，并且他的品牌是动感地带。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
//created on: 2016-3-26//业务规则决策配置 by tangjie
package newlandframework.ruleengine

//list any import classes here.
import newlandframework.ruleengine.UserProduct;
import newlandframework.ruleengine.Users;
import newlandframework.ruleengine.LuckUsers;

//declare any global variables here

rule "genLuckyUsersRule"
  dialect "mvel"
  when
    $luck : LuckUsers()
    $userFamilyProduct :  UserProduct( productId == UserProduct.FAIMILYPROUDCT )
    $userVpnProduct :  UserProduct( productId == UserProduct.VPNPRODUCT )
    $user : Users(userProduct contains $userFamilyProduct) and Users(userProduct contains $userVpnProduct)
    
    eval($user.userBrand == Users.MZONE)
  then
    //actions
    System.out.println("family:"+$userFamilyProduct.productId);
    System.out.println("vpn:"+$userVpnProduct.productId);
    System.out.println("msisdn:"+$user.msisdn);
    
    $luck.homeCity = $user.homeCity;
    $luck.msisdn = $user.msisdn;
    $luck.userId = $user.userId;
end
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　最后我们可以在客户端中初始化一个属性（homeCity、msisdn、userId）都是空（null）的幸运用户对象LuckyUsers，然后传入一个用户刚好符合上述业务规则决策条件的“事实”用户，调用方式参考代码如下：

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
//创建一个默认的幸运用户对象
LuckUsers luck = new LuckUsers();

//业务规定的vpn产品对象
UserProduct vpn = new UserProduct();
vpn.setProductId(UserProduct.VPNPRODUCT);

//业务规定的家庭产品对象
UserProduct family = new UserProduct();
family.setProductId(UserProduct.FAIMILYPROUDCT);

//存放用户已经订购的产品列表
List<UserProduct> listProduct = new ArrayList<UserProduct>();

//创建测试用户，用户号码119，用户归属地市591，用户标识1240
Integer homeCity = new Integer(591);
Integer userId = new Integer(1240);
Integer msisdn = new Integer(119);
//假设用户还订购了其他的4G飞享套餐，产品编码是1000000003
Integer otherProductId = new Integer(1000000003);

UserProduct userProduct1 = new UserProduct();
userProduct1.setHomeCity(homeCity);
userProduct1.setProductId(otherProductId);
userProduct1.setProductName("4G飞享套餐");
userProduct1.setUserId(userId);
listProduct.add(userProduct1);

UserProduct userProduct2 = new UserProduct();
userProduct2.setHomeCity(homeCity);
userProduct2.setProductId(UserProduct.VPNPRODUCT);
userProduct2.setProductName("VPN产品");
userProduct2.setUserId(userId);
listProduct.add(userProduct2);

UserProduct userProduct3 = new UserProduct();
userProduct3.setHomeCity(homeCity);
userProduct3.setProductId(UserProduct.FAIMILYPROUDCT);
userProduct3.setProductName("家庭产品");
userProduct3.setUserId(userId);
listProduct.add(userProduct3);

Users user = new Users();
user.setHomeCity(homeCity);
user.setMsisdn(msisdn);
user.setUserBrand(Users.MZONE);
user.setUserId(userId);
user.setUserProduct(listProduct);

//业务规则关注的事实对象
ArrayList<Object> elements = new ArrayList<Object>();
elements.add(vpn);
elements.add(family);
elements.add(userProduct1);
elements.add(userProduct2);
elements.add(userProduct3);
elements.add(user);
elements.add(luck);

//加入业务规则引擎中执行决策
new BusinessRuleRunner().notify(drlContent, elements);
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

　　好了，我们执行一下代码，看下运行结果：

![img](https://images2015.cnblogs.com/blog/913759/201603/913759-20160326083253323-1598169289.jpg)

　　可以很清楚的看到，符合条件的用户，果然被我们找到，并且打印出来了。就是上面homeCity = 591，msisdn = 119，userId=1240的记录。

　　并且后续如果业务部门又改变业务规则，我们只要重新编写或者修改一个规则配置，然后重新发布、刷新缓存，既可以符合要求，又省去了很多代码编译、发布、上线等等一系列繁琐的中间步骤。最关键的是我们的代码框架也会变得非常灵活。

　　本文的内容是基于本人日常开发工作中应对复杂多变的业务规则的一种解决方式的设想，当然其中肯定有很多需要完善优化的地方，希望在此抛砖引玉，不吝赐教！

# 什么是规则引擎？

- 是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来
- 规则引擎的核心就是获取knowledge（知识）
- 应用knowledge到特定的数据上（fact）
- 使用 “production rules（产生式规则）” IF <conditions> THEN <actions> Rule表达逻辑（任何逻辑都可以用这种方式表达）

# 什么是规则？

- 一个rule由conditions，和actions组成。当所有的conditions匹配，rule可能“fire”  Conditions即LHS（left hand side）
- Actions即RHS（right hand side或者consequence）
- Rule操纵应用程序中的数据（ fact ）

# 术语:

- Rule engines（比如Drools）使用正向或者反向链（或者混合使用）
- 正向链从事实到结论的推理。rule在LHS conditions匹配的时候执行。Actions可以改变facts，并可能导致新rule被fire。
- 反向链指则是从假设,即要证明的结论,到事实的推理

# 推理引擎：

- 规则系统的大脑实际上就是一个推理引擎，用于匹配facts和rules
- 推理引擎将事实、数据与产生式规则进行匹配（模式匹配），以推出结论
- 当匹配被找到，rule actions被fire
- Actions—经常会改变facts的状态，或者在应用上执行一些“外部”action

​     ![img](https://images2017.cnblogs.com/blog/1160543/201711/1160543-20171112182244372-845764888.png)

# 正向链

![img](https://images2017.cnblogs.com/blog/1160543/201711/1160543-20171112184817903-103004687.png)

# 何时使用规则引擎

- 当没有更让人满意的“传统”方案
- 当遇到以下问题：

　　　　太复杂
　　　　没有已知的算法
　　　　太易变

# JBoss Drools

　　Drools是一个业务逻辑集成平台，基于JAVA和RATE算法的产生式规则引擎实现，是Red Hat旗下的开源产品.

 

　　Drools历史
　　　　2001年，Drools问世，基于线性蛮力搜索
　　　　在2.0版本后，又基于Rate算法进行了重写，提高了Drools的性能，规则文件主要以XML为主
　　　　在3.0版本，引入了.drl文件格式，它是一种领域特定语言（DSL）专门针对规则编写
　　　　在5.0版本，引入了Drools Funsion/Flow rule等重要功能模块

　

## 　　Drools组成模块

​        ![img](https://images2017.cnblogs.com/blog/1160543/201711/1160543-20171112185334559-672811766.png)

 

 

# 总结：

- Rules技术提供了一种新的方式用于创建业务应用系统，通过“声明式”的rule语言写业务逻辑，而不是传统的程序语言
- Rule engine非常适合解决复杂问题，且在没有更好的其他
- Rule engine非常适合用来表述业务逻辑

规则引擎系列—规则引擎背后的算法

阿健2020 2020-04-19 16:22:19  2624  收藏 5
分类专栏： Java 文章标签： java 业务规则设计
版权
1.算法简介
目前，业界主流的规则引擎使用的算法，都是RETE算法。什么是RETE算法呢，以下算法的定义，是从其他官方博客摘抄而来，同时加入了自己的理解。

Rete 算法最初是由卡内基梅隆大学的 Charles L.Forgy 博士在 1974 年发表的论文中所阐述的算法 , 该算法提供了专家系统的一个高效实现。自 Rete 算法提出以后 , 它就被用到一些大型的规则系统中 , 像 ILog、Jess、JBoss Rules 等都是基于 RETE 算法的规则引擎。

Rete 在拉丁语中译为”net”，即网络。Rete 匹配算法是一种进行大量模式集合和大量对象集合间比较的高效方法，通过网络筛选的方法找出所有匹配各个模式的对象和规则。

其核心思想是将分离的匹配项根据内容动态构造匹配树（其实是构造一个DAG,有向无环图），以达到显著降低计算量的效果。Rete 算法可以被分为两个部分：规则编译和规则执行 。当 Rete 算法进行事实的断言时，包含三个阶段：匹配、选择和执行，称做 match-select-act cycle。本质上是利用空间换换时间。

2.术语了解
Fact，事实对象，对于真实事物或者事实的承载对象，例如：登录事实对象，可能包含：登录ip，用户id，登录设备，近一一小时内登录成功次数，近一小时登录失败次数，可以理解为规则引擎所需要的输入参数。规则引擎会基于Fact对象和规则，构造DAG。

Rule，规则，由条件构成和结论构成的推理语句。例如：if ... then ... else .....，if 登录ip in 黑产ip列表内，then 命中登录黑名单 else 放行。这里的规则通指，if..then...else...的原子规则，而非多条件多关系的规则集。
LHS，规则的左半部分，通常指规则的if.... 部分。进一步细化，一般是指，具体的左半边因子，操作符，右半边因子。例如：if 登录ip in 黑产ip列表内。左半边因子即登录ip，操作符即in，右半边因子即黑产ip列表。
RHS，规则的右半部分，通常指规则的then以及else部分。一般是指具体的action，因为then以及else，往往是对应具体的动作，例如：或者给其他参数赋值（赋值动作），执行其他的函数（执行方法动作）。
知识包，知识包是打包了，某一个业务场景下，所有的规则，所有的库文件（Fact元数据描述库，动作库，常量库，枚举库），甚至包括评分卡，决策流等。一个知识包往往是一个业务场景下大的集合，知识包都有版本概念，可以发布新版本的知识包，当有新的知识包发布，所有依赖某个业务规则的客户端，都会更新为最新知识包下的规则。
Session，session代表一次回话，一个回话往往对应一个工作区，即包括整体流程的执行。
workmemory，工作区，即执行规则的内存空间，一个workmemory对应一次回话，对应一次规则的执行。
Rete，由LHS部分构成的规则网络，通常是dag图。
Agenda，议程，决定执行哪些RHS的Action。
Action，动作，RHS部分对应的具体动作，例如：赋值，打印参数，执行方法等。
这里插入一段对DAG的解释，dag即有向无环图，在图论中，如果一个有向图无法从某个顶点出发经过若干条边回到该点，则这个图是一个有向无环图（DAG图）。

例如：



3.核心流程
算法整体分为两部分：1）规则编译和运行时执行，规则编译即把规则编译构造成Rete网络，也即DAG图。2）运行时执行，根据构造的DAG图，带入FACT对象，分配一块workmemory，开始进行匹配执行。

3.1 规则编译
rete网络图

节点解释：

root node（输入起始节点）
one-input node（单fact的条件匹配）
two-input node（多facts的联合join）
terminal node（终止节点，走到此节点，则规则匹配完成）
one-input node再细分为：

Type Node：类型节点，有的地方也叫ObjectTypeNode。主要作用：定位事实属性。fact从根节点进入后，会立刻进入TypeNode节点。确定fact的类型，这里是根据class类型去确定，如果是有多个fact对象，则会被拆分为多个TypeNode，例如上文的登录fact则只有一个TypeNode。即上图的红色节点部分。
Alpha Node：对fact的属性进行匹配判断。Alpha 节点是规则的条件部分的一个模式。通常用于评估字面的条件。例如，登录ip in 黑产ip列表，这个可以理解为一个Alpha Node。在图中AlphaNode未直接体现出来，但是AlphaMemory即AlphaNode所在位置。
two-input node再细分为：

Beta Node：则相对更为复杂一些，需要实现了两个fact的关联与匹配。作用：用来对2个对象进行对比、检查。约定BetaNode的2个输入称为左边（Join Node）和右边。左边通常是一个a list of objects，右边（Not Node）通常是 a single object。每个Bate节点都有自己的终端节点等组成。BetaNode具有记忆功能，左边输入的叫做BetaMemory，会记住所有的语义，右边输入叫做Alpha Memory，会记住所有到达过的对象。
Join Node：用于连接操作的节点，相当于and。属于Beta Node类型节点。
Not Node：根据右边输入对左边输入的对象数组进行过滤，两个NotNode可以完成 exists 检查。
LeftInputAdapterNodes: 将单个对象转化成对象数组。
例子（来自IBM DEVELOPER论坛）：

rule
when
    Cheese( $cheddar : name == "cheddar" )
    $person : Person( favouriteCheese == $cheddar )
then
    System.out.println( $person.getName() + " likes cheddar" );
end
rule
when
    Cheese( $cheddar : name == "cheddar" )
    $person : Person( favouriteCheese != $cheddar )
then
    System.out.println( $person.getName() + " does not like cheddar" );
end
说明：

两个Fact对象，Cheese与Person，即两个TypeNode, Cheese与Person。即两个Alpha Node，Cheese.name与Person.favouriteCheese,

但是此处Person.favouriteCheese不能严格称之为AlphaNode，这个应该是BetaNode。



从图上可以看到，编译后的RETE网络中，AlphaNode是共享的，而BetaNode不是共享的。两条规则的BetaNode的不同。然后这两条规则有各自的Terminal Node。即：AlphaMemory是共享的，BetaMemory是不共享的

例子（真实的案例）：





3.2 运行时执行
匹配过程如下：

1) 对于每个事实，通过 select 操作进行过滤，使事实沿着 rete 网达到合适的 alpha 节点。

2) 对于收到的每一个事实的 alpha 节点，用 Project( 投影操作 ) 将那些适当的变量绑定分离出来。使各个新的变量绑定集沿 rete 网到达适当的 bete 节点。

3) 对于收到新的变量绑定的 beta 节点，使用 Project 操作产生新的绑定集，使这些新的变量绑定沿 rete 网络至下一个 beta 节点以至最后的 Project。

4) 对于每条规则，用 project 操作将结论实例化所需的绑定分离出来。

如果把 rete 算法类比到关系型数据库操作，则事实集合就是一个关系，每条规则就是一个查询，再将每个事实绑定到每个模式上的操作看作一个 Select 操作，记一条规则为 P，规则中的模式为 c1,c2,…,ci, Select 操作的结果记为 r(ci), 则规则 P 的匹配即为 r(c1)◇r(c2)◇…◇(rci)。其中◇表示关系的连接（Join）操作。

Rete 网络的连接（Join）和投影 (Project) 和对数据库的操作形象对比，如图所示：



3.3 Rete算法的特点
优点：

a． Rete 算法是一种启发式算法，不同规则之间往往含有相同的模式，因此在 beta-network 中可以共享 BetaMemory 和 betanode。如果某个 betanode 被 N 条规则共享，则算法在此节点上效率会提高 N 倍。

b. Rete 算法由于采用 AlphaMemory 和 BetaMemory 来存储事实，当事实集合变化不大时，保存在 alpha 和 beta 节点中的状态不需要太多变化，避免了大量的重复计算，提高了匹配效率。

c. 从 Rete 网络可以看出，Rete 匹配速度与规则数目无关，这是因为事实只有满足本节点才会继续向下沿网络传递。

不足：

a. RETE 算法使用了β存储区存储已计算的中间结果, 以牺牲空间换取时间, 从而加快系统的速度。然而β存储区根据规则的条件与事实的数目而成指数级增长, 所以当规则与事实很多时, 会耗尽系统资源 。
————————————————
版权声明：本文为CSDN博主「阿健2020」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/y510662669/article/details/105606196/