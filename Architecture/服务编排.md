# 服务编排

## DSL设计

为了实现服务编排，需要定义一个数据结构来描述服务之间的依赖关系、调用顺序、调用服务的入参和出参等等。之后对获取的结果进行处理，也需要在这个数据结构中具体描述对什么样的数据进行怎么样的处理等等。所以需要定义一套DSL（领域特定语言）来描述整个服务编排的蓝图。



## 架构设计

![服务编排](C:/Users/DELL/Downloads/lemon-guide-main/images/Solution/服务编排.png)

- Facade：对外提供统一接口，供客户端调用
- Parser：对于输入的DSL进行解析，解析成内部流转的数据结构，同时得到所有的task，并且构建task调用逻辑树
- Executor：真实发起调用的模块，目前支持平台内部的RPC和HTTP调用方式，同时对HTTP等其它协议有良好的扩展性
- DataProcessor：数据后处理。这边会把所有接口拿到的数据转换层客服场景这边需要的数据，并且通过设计的一些内部函数，可以支持一些如数据半脱敏等功能
- 组件插件化：对日志等功能实现可插拔，调用方可以自定义这些组件，即插即用



## 主要特点

主要特点如下：

- 采用去中心化设计思路，引擎集成在SDK中。方案通用化，每个需要业务数据的场景都可以通过框架直接调用数据提供方
- 服务编排支持并行和串行调用，使用方可以根据实际场景自己构造服务调用树。通过DSL的方式把之前硬编码组装的逻辑实现了配置化，然后通过框架引擎把能并行调用的服务都执行了并行调用，数据使用方不用再自己处理性能优化
- 使用JSON DSL 描述整个工作蓝图，简单易学
- 支持JSONPath语法对服务返回的结果进行取值
- 支持内置函数和自定义指令（语法参考ftl）对取到的元数据进行处理，得到需要的最终结果
- 编排服务树可视化

**目录：**
 一、微服务编排的必要性
 二：3种常见的微服务编排方式
 1、Orchestration（编制）
 2、Choreography（编排）
 3、API网关
 三、微服务编排的框架（Orchestration方式）
 1、流程编排的思路
 2、流程编排的模型
 3、适配参数
 4、流水号
 5、调用链分析
 四、微服务编排的事务一致性
 五、微服务编排的监控工具支撑

### 一、微服务编排的必要性

微服务是目前流行的一种新兴的软件架构风格，在微服务体系结构中，可以将应用分解为多个更小颗粒度的服务, 各个服务可以由不同的团队并行独立开发、部署。

![img](https:////upload-images.jianshu.io/upload_images/9812895-19404e9a6e7d358f.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

（图片来源：[https://www.nginx.com/blog/introduction-to-microservices/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.nginx.com%2Fblog%2Fintroduction-to-microservices%2F)）

以一个出租车调度软件为例，最开始是一个单体应用，应用核心是业务逻辑，由定义服务、域对象和事件的模块完成。尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。随着时间增加，功能逐渐增多，代码越来越多，这个软件就会越来越难维护。这时使用微服务架构就是不错的选择。一个微服务一般完成某个特定的功能，比如定单管理、客户管理等等。每一个微服务都有自己的业务逻辑和适配器。一些微服务还会发布API给其它微服务和应用客户端使用。其它微服务完成一个Web UI，运行时，每一个微服务实例可能是一个Docker容器。

《The Art of Scalability》(中文书名：架构即未来) 一书介绍了一个应用横向扩展所需要遵守的AKF扩展模型。根据AKF扩展模型，横向扩展实际上包含了三个维度，而横向扩展解决方案则是这三个维度上所做工作的结合。X轴表示水平复制，Y轴表示应用功能拆解，Z轴表示按数据拆分。微服务架构模式对应于代表可扩展模型的Y轴。

![img](https:////upload-images.jianshu.io/upload_images/9812895-106c00a0e57d0a19.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/720/format/webp)

image

当一个系统采用了微服务架构后，原有的业务可能并没有发生变化，但系统已被拆分成了很多新的微服务，与传统架构相比，微服务架构下会更依赖通过各微服务之间的协作来实现一个完整的业务流程，这种协作就是服务编排。编排涉及到RPC、分布式事务等，需要有完善的编排框架来支撑。

### 二：3种常见的微服务编排方式

目前有3种常见的微服务编排方式，实现微服务的组合与协调，可根据开发项目的实际情况进行选择。

##### 1、Orchestration（编制）

Orchestration**面向可执行的流程**：通过一个可执行的流程来协同内部及外部的服务交互，通过流程来控制总体的目标、涉及的操作、服务调用顺序。

Orchestration和BPM、ESB的思想很相似，首先要有一个**流程控制服务**，该服务接收请求，依照业务逻辑规则，依次调用各个微服务，并最终完成处理逻辑。可以把控制服务视作BPM、ESB引擎，微服务视作BPM、ESB的各种组件。

Orchestration实现方案多是**同步**的。

**优点**：
 流程控制服务时时刻刻都知道每一笔业务究竟进行到了什么地步，监控业务成了相对简单的事情。
 **缺点**：
 1）流程控制服务很容易控制了太多的业务逻辑，耦合度过高，变得臃肿。
 2）各个微服务退化为单纯的增删改查，失去自身价值。

##### 2、Choreography（编排）

Choreography**面向协作**：通过消息的交互序列来控制各个部分资源的交互，参与交互的资源都是对等的，没有集中的控制。

Choreography可以看作一种**消息驱动模式**，或者说是订阅发布模式，每笔业务到来后，各个监听改事件的服务，会主动获取消息，处理，并可以按需发布自己的消息。可以把不同队列看作不同种类的消息，微服务看作消息处理函数。

Choreography实现方案多是**异步**的。

**优点**：
 耦合度低，每个服务都可以各司其职。
 **缺点**：
 1）业务流程是通过订阅的方式来体现的，很难直接监控每笔业务的处理，因此难于调试。
 2）由于没有预定义流程，所以很难在事前保证流程正确性，基本靠事后分析数据来判断。
 3）当一个业务流程会嵌入到多个服务中时，维护会很困难。
 **建议**：
 1）小粒度的服务需要组合，服务的粒度越小，越需要组合。
 2）增加相应的监控系统，来保证业务顺畅进行。

##### 3、API网关

API网关可以看作一种简单的**接口聚合/拆分的方式**：每笔业务到来后先到达网关，网关调用各微服务，并最终聚合/拆分需反馈的结果。

API网关其实就是一个**适配网关**，比如对于Web端，可以一个页面同时发起几十个请求，而对于移动端，最好是一个页面就几个请求。而采用API网关，后面的微服务可以是相同的。

**优点**：
 对外接口相对稳定。
 **缺点**：
 只适合业务逻辑较为简单的场景，业务逻辑过于复杂时，网关接口耦合度及复杂度会急剧升高，变得臃肿。

### 三、微服务编排的框架（Orchestration方式）

对编排流程、适配参数、调用链分析等方面思路的考量，构成微服务编排的框架思路。

##### 1、编排流程的思路

原子服务提供REST接口或者监听事件，通过流程编排这些原子服务来实现一个新的复杂服务。

![img](https:////upload-images.jianshu.io/upload_images/9812895-59869d9042a34b9a.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

##### 2、编排流程的模型

- 活动模型。例如（赋值、invoke（调用）、空）
- 控制模型。例如（顺序、分支、循环、异常抛出、异常捕获、并行）

当然，有很多编排框架提供了更多方便的活动，比如普元的编排框架提供了本地调用、rest调用、webservice调用等活动，从而在使用上更加的方便，有了这些基本的模型，我们就能方便的编排出复杂的业务流程。（如下图）



![img](https:////upload-images.jianshu.io/upload_images/9812895-d35bc8d7f8395ed9.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

20170605155021851.jpg

在invoke（调用）的时候我们知道有同步和异步的区别。同步实现起来简单，但是在多级级联编排的时候要避免因为某个服务的长响应时间导致雪崩效应，一般可以通过设置合理的超时时间限流和服务熔断策略来避免；同样，在异步调用的时候，应该能自动缓存上下文和避免缓存爆掉，能自动建立异步响应和请求之间的关联。同样，提到并行也必须考虑不同的聚合方式，比如是部分聚合还是全部聚合。（如下图）

![img](https:////upload-images.jianshu.io/upload_images/9812895-8377cd3456f80d6e.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

##### 3、适配参数

流程编排完成之后，我们还需要给每个被编的服务提供正确的参数，是一个适配的过程。
 一个编排服务（abcd）由a、b、c、d服务编排而成，每个服务都会有自己的出参入参。适配的过程就是从上下文中给入参赋值以及将出参的结果写入到上下文中。（如下图）



![img](https:////upload-images.jianshu.io/upload_images/9812895-2a22d8fd090186dd.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

20170605155122120.jpg

编排服务执行到不同阶段，组成上下文的模型也是不一样的。从最初服务的开始执行的时候，上下文中只有系统级的参数和入参（请求报文），到执行完一个被编服务后上下文就会增加这个被编服务的出参（响应报文），执行上下文是一个不断增大的过程。所以适配不仅仅存在于编排服务的入参和被编服务的入参之间，还存在于被编服务和在其之前的服务出参之间。（如下图）

![img](https:////upload-images.jianshu.io/upload_images/9812895-2535760ad5358385.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

20170605155200918.jpg

实现适配最直接的方式是用手工编码完成点到点的映射赋值，但有更高效的方式，通过使用元数据对所有的出参和入参标记着色，然后就可以自动完成同样颜色之间的自动映射。这种标志着色可以靠数据字典实现。（如下图）



![img](https:////upload-images.jianshu.io/upload_images/9812895-c21b666bd375517f.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

这里的数据字典是指抽象出业务含义的基本数据项，如账户，交易额等。通过这些数据字典可以定义出服务所需的的数据结构（服务参数和服务返回值），这样不同的数据结构之间可以按照数据字典进行自动适配。（如下图）

![img](https:////upload-images.jianshu.io/upload_images/9812895-0278e379e523dc6c.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

##### 4、流水号

编排服务在执行上下文的组成模型过程中，框架也会产生一部分数据，这一部分数据主要是流水号(id)和安全方面的考量。按照《基于微服务的企业应用架构设计范式》流水号的生成应该遵循GAIR模式。
 **GlobalID:** 全局流水号，如果请求中的globalId为空，则编排服务生成，否则保持不变。
 **AnswerID:**响应流水号，服务提供者生成，可以作为提供者受理的凭证
 **InRequestID:** 前台流水号，由前台生成
 **RequestID:**请求流水号，编排服务的协调器生成，生成规则由服务提供者定义。（如下图）

![img](https:////upload-images.jianshu.io/upload_images/9812895-e6f9908ac613a8eb.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

20170605155354092.jpg



##### 5、调用链分析

随着服务的增多，对调用链的分析也会越来越复杂。在一个由很多微服务组成的系统中，他们之间的调用关系会形成复杂的网络。

Google针对服务化应用全链路追踪的问题发表了Dapper论文，介绍了他们如何进行服务追踪分析，其基本思路是在服务调用的请求和响应中加入ID，标明上下游请求的关系，利用这些信息，可以可视化地分析服务调用链路和服务间的依赖关系。（如下图）

![img](https:////upload-images.jianshu.io/upload_images/9812895-08e741cd19bab756.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

通过服务调用追踪生成的服务调用栈，可以查看在哪一步出现了错误，以及发现哪里的调用较慢，进行系统优化。（如下图）

![img](https:////upload-images.jianshu.io/upload_images/9812895-c83de3f5f84c3723.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

能编排流程，能适配参数，这个编排框架已经具备运行的能力，接下来要考虑的就是事务的一致性问题。

### 四、微服务编排的事务一致性

依据CAP理论，分布式系统需要在可用性和一致性之间做出选择。如果选择提供一致性，就需要付出在满足一致性之前阻塞其他并发访问的代价，阻塞持续的时间往往不能确定，尤其是在系统已经表现出高延迟时或者网络故障导致失去连接时，因此，可用性一般是更多人的选择，但是在服务和数据库之间维护数据一致性是非常根本的需求，**编排框架应该选择满足最终一致性。**

补偿模式是一种很好的实现最终一致性的途径。 **补偿模式核心思想是：针对每个操作，都要注册一个与其对应的补偿（撤销）操作，一般来说操作本身和其补偿操作会在一个事务里完成，当其后续操作失败后，需要按相反顺序完成前面注册的所有撤销操作。**

通过一个实例来说明：一家旅行公司提供预订行程的业务，可以通过公司的网站提前预订飞机票、火车票、酒店等。假设一位客户规划的行程是，(1)上海-北京6月19日9点的某某航班，(2)某某酒店住宿3晚，(3)北京-上海6月22日17点火车。在客户提交行程后，旅行公司的预订行程业务按顺序串行的调用航班预订服务、酒店预订服务、火车预订服务。最后的火车预订服务成功后整个预订业务才算完成。如果火车票预订服务没有调用成功，那么之前预订的航班、酒店都得取消。取消之前预订的酒店、航班即为补偿过程。（如下图）

![img](https:////upload-images.jianshu.io/upload_images/9812895-db6d56577f63ea82.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

在补偿模式中，我们要求参与补偿的微服务必须提供补偿操作，并且补偿操作必须是幂等的，补偿框架可以在异常时自动调用补偿操作完成补偿。

跟RPC比，补偿模式的核心价值是少了锁资源的代价，流程也相对简单，但实际操作中，补偿操作不太好定义，其中间状态处理也会比较棘手。

现在RESTful作为一个轻量级的rpc协议已经被广泛采用，能不能很好的支持RESTful服务的事务一致性也是衡量编排框架的是否成熟的一个标准。

一个通过RESTful扩展规范来支持补偿模式事务一致性的思路：通过PATCH的HTTP Method来表示compensation操作，并且支持通过服务来查询编排服务执行的状态。（如下图）



![img](https:////upload-images.jianshu.io/upload_images/9812895-bef4b8e5e9f64ce4.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

> 补偿模式一个常见的坑：由于是通过rpc的调用，因为网络和调度的关系，可能出现补偿请求比原交易先到达的情况，这会导致补偿操作直接会失败，因为此时原交易尚未发生，最终原交易到达时会被成功的执行，最终就导致了事务不一致。

填这个坑的办法就是在编排框架发现补偿操作补偿的原交易不存在时，补记录一条原交易的流水，从而保证原交易晚到时会因为记录流水失败而不会成功。（如下图）



![img](https:////upload-images.jianshu.io/upload_images/9812895-d4768ca3ccd39816?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

图片描述

### 五、微服务编排的监控工具支撑

在生产环境中，我们需要通过查看日志来排除故障，应该有支持日志全路径回放的工具，来帮助我们快速定位故障。

本文所讲的编排实际是编制，是一种集中式的控制，也就意味着如果被编排的服务有响应缓慢的情况，可能会影响到其他服务。这时候我们需要更快的监控来帮助我们发现这类服务，从而尽早优化。监控工具需要具备以下功能：

- 通过可视化分布式系统的模块和他们之间的相互联系来理解系统拓扑。点击某个节点会展示这个模块的详情，比如它当前的状态和请求数量。
- 实时监控应用内部的活动线程。
- 可视化请求和响应数量来定位潜在问题（请求时间段分布、错误请求、响应时长等）。
- 在分布式环境中为每个调用生成可视图，定位瓶颈和失败点。
- 查看应用上的其他详细信息，比如CPU使用率，内存/垃圾回收，TPS，和JVM参数。



作者：沉落的星星
链接：https://www.jianshu.com/p/54e2e223dbac
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

一. **背景** 

1. 应用系统的架构演变随着业务的越来越复杂，需要更多的思考、更高维度的抽象。
2. 将组织逻辑与业务实现分离，使业务应用更关注自身的领域内容。

二. **目标**

　　将业务流程可视化、最终展现出全局业务视图，并可以动态调整业务链路。结尾附上示例代码。

　　大部分现行的系统都是通过繁荣的代码来实现业务逻辑的拼装，当业务变得极其复杂的时候会变得可读性极差，可维护性降低。

　　服务编排的理想目标是开发人员只注重简单接口（行为）的开发，业务人员可以通过编排系统实现应用及系统的组装和运维。简单一点理解的话就是讲服务化衍进为工具化（理想状态，现实很难）。

三. **产出** 

1. 一个中心化的流程配置站点，效果如图（引用zeebe的系统图）![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210622162827802-903517564.jpg)
2. 一个轻量级的编排网关，使用网关模式(中心化)、业务接口将不直接暴露服务，所有请求由网关组织，类似总线模式。优点在于对于新的应用，开发者只需关注自己的原子功能实现，缺点在于对于旧的应用，部分业务接口需要拆解改造。
3. 一个客户端代理，使用代理模式（非中心化）、中心化的配置站点根据版本下发规则文件，需要在各自应用系统中引用代理组件,可以自动/按需进行服务组织调用与上下文适配。

　　 **ps：对于网关模式和代理模式一般只需要采取1种，具体根据自己的实际场景选择。**

四. **与工作流区别**

1. 从实现方向上来说，工作流引擎的核心实现是一种状态机、可以理解成一套中心化的服务；服务编排的核心是一套开发框架，它依赖接入应用的具体场景。
2. 从业务方向来说，工作流引擎侧重构建定义执行过程，强调规范、快速开发；服务编排侧重业务建模、组装、部署及管理。
3. 从使用场景来说，工作流引擎一室现在最大的使用场景为办公自动化；服务编排可以理解成SOA的产物。

五. **应用场景分析**

　　**![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210622162956684-430102956.jpg)**

　　简单的来说，这种场景对应网关模式，无需代码侵入，由编排网关统筹管理服务调度，粒度可以足够的细，一次db操作，一次文件操作，一次接口调用都可以作为调度的基本单元。端点的概念在后面实现里会讲。

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210622163239736-477538152.jpg)

这种场景为代理模式，需要少量的代码侵入，侵入部分为编排的组件代理，这种模式可以解决中心化的问题，各自应用自己治理。

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210622164718816-965564967.jpg)

　　宏观的概念为企业应用模式，通过编排引擎将应用系统、数据资源和互联网资源组成一个统一的整体。看起来是不是和ESB有点像，很快我们会总结和ESB的差异。

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210622164849450-646715922.jpg)

　　核心模块参考Netflix conductor 、Zeebe、Apache Camel等成熟产品 结合我们自己业务特性，目标为轻量级、可扩展、组件化的设计模式。

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210622165000891-208595300.jpg)

 　黄色的部分就是服务编排组件和ESB产品重叠的内容，服务编排组件相当于是ESB产品成熟架构之上的一些功能拆解，并逐渐衍生为更贴合互联网主流技术（例如微服务）的替代方案。

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210622172142412-1129427073.jpg)

　　上面我们聊了2种模式，我们通过管道与业务域的关系来解释部署方案的差异

　　管道是消息传递的载体。由于编排引擎的核心为组件化的实现方式，其部署的方式相对灵活。

　　1. 管道的范围决定了业务域的大小 高纬度能以整个团队业务为维度，低纬度能以个别应用为维度。

　　2. 中心化部署 好处是可以避免下层应用代码的侵入并集中管理

　　3.非中心化部署 非中心化部署有2种方式

　　　　i）第一种为代码植入，这种方式不依赖管道作为消息载体，每一个植入应用都属于消息载体，并直接管理上下文。

　　　　ii）第二种为ServiceMesh的边车模式，将控制与业务分离。好处是无需进行代码侵入，缺点是当前环境该模式并不成熟，容易带入运维成本。![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210622172444662-258581772.jpg)

　　除了路由可视化，还可以利用JMX实现扩展管理，Mbean中包含了所有可更新对象。 消息管道中按每笔事件定义通信ID,通信ID在一次传递过程中不会变化，其中包含版本信息。 新版本的产生不会影响到旧的事件。

**六. 核心组件实现
**

**![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210622173417504-329818312.jpg)**

重点参考开源产品Apache Camel。最核心的是DSL语言、端点、组件、路由、注册表、格式转化。

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623112317935-902408122.jpg)

DSL 其实是 Domain Specific Language 的缩写，相对DSL的定义就是 GPL(General Purpose Language)

常见的DSL有SQL、Regex ，常见的GPL有Objective-C、Python...

DSL 最大的设计原则就是简单，通过简化语言中的元素，降低使用者的负担设计语法和语义。Camel组件中设计DSL语法和语义，定义 DSL 中的元素并实现 parser，对 DSL 解析，最终通过解释器来执行。目前支持Java DSL和XML DSL。其核心定义就是描述了一次路由行为的上下文、内容、类型、依赖、逻辑等等。运行时编排系统就会载入实现定义的DSL文件，会按照DSL文件中定义的路由行为来执行。

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623095614807-1284208926.jpg)

回到上面提出的问题，什么是端点(Endpoint)。端点是camel的抽象概念。可以理解成信道末端模型，系统可以利用信道收发消息。更通俗一点来讲，你可以将端点理解成一次通信行为的支撑/目标支点。这个支点可以支持非常多的协议，例如http、ftp、rpc等等等等。这从基础上就决定了我们的通信信道不仅仅可以支撑现在常用的服务/微服务场景，更能从更多底层元素来运作编排行为。

但是端点需要满足一定的规则要求，首先是路由Url，示例中的file代表Scheme，定义了端点的协议类型。Context path定义通信的路径及端口等。Options定外额外的一些扩展信息，根据协议和场景的特殊性可以自定义逻辑和内容。

端点还关联着生产者、消费者、交换机等概念，这些内容的设计和实现和RabbitMq同源，RabbitMq的底层设计就是使用了Camel的框架。

关于这些概念可以参与我之前的文章 https://www.cnblogs.com/dubing/p/4017613.html

组件的概念如下图

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623102410421-1949040289.jpg)

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623102607315-2126385035.jpg)

组件的实现方式为监控指定目录中的文件。此目录中的文件描述了组件的名称、组件类的全路径名。 大部分组件的java代码模块都与模块核心模块做了分离，因为他们常常依赖第三方的包，如果不分离，将会使核心包过度膨胀。

整个端点实现的类图可以参考下图

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623103001862-134438130.jpg)

下面我们接着讲路由

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623103453102-1155360778.jpg)

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623103541545-139672057.jpg)

 ![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623103610307-174259742.jpg)

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623110536804-642953684.jpg)

Multicast表示将消息复制多份串行/并行分开给所有消费通道。

RecipientList区别于多播模式，解决消费通道优先级问题。收件人列表可以动态维护。

routeSliping是将消息依次传入后面的节点进行处理,不会负责,后面的节点修改的是同一个消息。

此外还有多种传递类型，例如SPLIT将一份消息分离成不同部分传递给不同消息通道，Aggregator将不同消息来源合并给下游消息通道。

如果组件支持的模式不足以满足我们项目的特性需求还可以自定义规则

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623112355827-1044412857.jpg)

示例中根据choice-when 自定义路由规则。

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623110833615-85053468.jpg)

代码示例

![img](https://img2020.cnblogs.com/blog/87114/202106/87114-20210623112415430-2030869279.jpg)

本章总览了服务编排的设计，内容较多每一块的细节都可以单独拿出来详细解读，最后附上组件示例代码（示例代码为完全demo环境，如发现任何企业或者版权相关信息请联系我删除）

[组件示例下载 ](https://files.cnblogs.com/files/dubing/javaapp.zip)