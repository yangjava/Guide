# Devops平台开发

构建企业云原生DevOps体系，打造研发运维管理一体化平台
整个方案涵盖了创新管理-产品管理-项目管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

工具链复杂

痛点描述：多个工具在整个研发流程的各个节点行为割裂，完全依赖人为主观串联，流程多而杂、连贯性差、整体效率低下

解决方案

提供一站式工具链

提供一站式工具链，减轻工具选型成本，专注于业务创新

研发环境不隔离

痛点描述：Ops前移到Dev部门，迫使应用研发人员学习掌握Docker、K8S等底层云原生技术。一方面增加了应用研发人员学习的成本和学习门槛，同时也增加了人员招聘的难度。

解决方案

可视化操作界面屏蔽k8s

封装Docker、K8S等底层技术，为用户提供可视化操作页面，让传统应用研发团队无缝转型为云原生数字化应用研发团队

自动程度低，复用性差

痛点描述：传统企业IT系统欠缺自动化能力，各项能力很难被复用，自动化需要人为衔接，呈现出“半自动化”状态

解决方案

企业云原生数字资产沉淀

基于行云CloudOS构建的API、业务逻辑组件、微服务、算法等，形成积累，沉淀出企业独有的数字资产。通过持续的调用与迭代，沉淀到企业应用商店。形成一套高度抽象、可以快速复用的数字资产能力

数据分散、不透明

痛点描述：迭代流程数据分散在各自平台，不完整且不完全透明，需要人为收集整合与对比分析，重人工，易遗漏

解决方案

软件资产数字化归档

软件架构蓝图在线编排系统，拖拉拽式完成软件架构蓝图。业务组件与代码库关联，实现以架构图为核心的编码、测试、部署、运维监控，在线架构图与发布环境应用架构保持一致

方案框架

![devops](png\devops.png)



实现的功能：

安全账号管理  统一使用lapd平台账户登录，统一管理账户信息

需求管理 以需求为基准，关联项目，关联项目分支，

分支管理管理  管理gitlab上的项目，从gitlab下拉取代码

分支管理并自动合并代码分支  merge管理

maven工具自动打包

docker镜像管理 

k8s信息管理，查看日志等信息

实现技术：





# 基于Skywalking的分布式环境路由

什么是环境路由？

基于不同环境的隔离技术，基线环境和分支环境等实现

不同环境的路由实现原理





# 基于Skywalking的全链路追踪改造





# 分布式系统的可观测性实现

环境稳定性治理

1.高可用

2.分布式事务解决

3.











## 重构授信系统

1、增加业务支持性与可扩展性：
本次授信重构项目重新划分了控信机制与额度类型，该控信机制包含了行业通用的机制以及公司特
有的机制，能满足公司当前业务的各类模式，同时也具备可扩展性，若后期业务模式新增或发生变化，
通过新增额度类型，与对应的机制相关联，可在底层架构不变的情况下，较为快捷得实现扩展性。
2、增强系统风险控制能力：
当前业务类型层面新增了额度控制，未来在产品、项目等不同层面都留有额度控制的余地，便于实
现多层次系统性风险控制与校验。
3、增强管理需求的数据支撑能力：
当前业务部门在业务开展、绩效考核，以及出于其他需求需要获得系统相关数据统计支持的时候，
常见数据无法获得的情况，导致很多时候只能使用近似的数据作为替代，或者只能使用手工台账统计，
且与系统数据存在一定差异。本次重构将会在明细数据上存储得更为具体，以满足全方位数据统计的需
求，同时也便于问题定位与核对。
4、减少人工工作量：
当前系统很多场景的控制全依赖人工统计与监控，比如额度审批、在不同业务上的放款、临额审批
等系统监控都是空白，全依赖人工统计。而此次重构在一定程度上提升了系统校验与监控的职能，即使
眼下没有配置控制线，后期也有空间与能力支持系统性的风险控制。
5、增强系统建模能力：

区别于老系统的数据存储结构，本次重构的信息多为结构化存储，对于后期数据产品的开发与输出
也将成为强有力的支撑。
6、最大程度修正错误历史数据：
当前我司业务系统存在很大的赊销数据错误问题，该问题频繁出现，并且经分析发现数据错误的根
本原因早已无法精准定位，错误面也非常广泛，固额、临额、冻结、使用等各项数据均存在较多错误，
且错误累计时间已久，当前已到达无法完全修正的程度。本次重构必然需要迁移历史数据，趁此机会对
历史数据进行一次全面修正，以此为基准运行新模型，尽最大可能降低历史数据错误程度。

功能架构

1、控信机制：分为三类
（1）控制用信：适用担保额度、厂商赊销额度
（2）控制授信，通用额度：适用下游自用仟金顶额度
（3）控制授信，专项额度：适用上游自用仟金顶额度
2、额度类型分为四类：
（1）担保额度：切分不占额度、下游用信占上游担保额度
（2）厂商赊销额度：为下游使用上限，实际用信占上游担保额度
（3）下游自用仟金顶额度：下游身份使用的仟金顶额度
（4）上游自用仟金顶额度：上游身份使用的仟金顶额度
（5）不同额度类型数据及审批流程独立
3、额度控制层面：
（1）额度类型层面
（2）业务类型层面
（3）产品层面：（后期）



技术框架：

架构设计

授信客户=》 授信客户 来源 平台 银行 企业 经销商

授信账户设计==》时间期限  额度   科目ID  授信限额  授信客户双方

额度如何设计 冻结 解冻 使用 归还  余额=在途+使用中

因为有循环逻辑： 归还不归还

授信科目树=》客户 联保客户  业务类型  产品类型

授信申请是流程模型，使用activiti实现

授信限额是一个DAG模型，有向无环图模型

(使用消费券的模型)

流水模型=》 流水双方客户信息 金额  现金+需要使用的授信金额  时间字段

选择器模型=》选中图中的信息，扣除流水如果为负数则不行

​            单独券+ 可以共享的券

分录模型=》 每个层级的流水都会扣除



热点账户问题如何解决：

开发周期

历史数据处理：

开发中遇到的问题：

沟通问题交流问题

历史数据处理难点



流水重新执行逻辑：

1.按照时间顺序重新组装数据，形成EventSource模式，流数据

业务逻辑核对：

授信使用额度=现在实点数（以放款信息为准）

授信流水冻结=放款流水冻结

在途流水=放款





热点账户问题如何解决：

一、热点账户
        热点账户就是高频进行扣款、入账的账户，也就是热点账户该条数据为热点数据，会被频繁更新。一般热点账户分为两种，一种是频繁扣款的热点账户，另外一种是频繁入账的热点账户。

 

二、热点账户常见问题
        1、性能瓶颈问题

        2、数据库压力问题
    
        3、成功率问题

 






三、纯修改余额方式及其特点
       1. 乐观锁



        操作方式：
    
                查询账户数据：
    
                        SELECT  BALANCE, STATUS, VERSION, … FROM ACCOUNT WHERE ID = ?
    
                计算余额:
    
                        POST_BALANCE = BALANCE + AMOUNT
    
                        或者
    
                        POST_BALANCE = BALANCE - AMOUNT
    
                更新账户余额：
    
                        UPDATE …. BALANCE = POST_BALANCE,VERSION = VERSION +1 WHERE ID = ? AND VERSION = ?
    
                        更新返回1，更新成功，返回0，更新失败，需抛出异常，回滚事务
    
                插入账户历史:
    
                        INSERT … 

 






        优点：
    
                不会存在阻塞，响应时间快；
    
                数据库没什么压力；
    
                在内存里可以完成很多复杂操作；
    
        缺点：
    
                成功率不高，真的存在并发时，失败的请求比较多；
    
                有效的性能依然不高；

 






        一般应对方案：
    
                采用重试的方式，立即重试三次，以提高成功率



        个人看法：
    
                这种重试在真正的有量的时候基本没啥作用，相反会徒增数据库的请求量，鄙人觉得这种重试只能解决请求量较小的时候的并发，比如突然同时进来两笔同一个账户的请求，处理失败的话进行重试是可以解决问题的；但是一瞬间进来200笔，甚至更多的话，这种重试没啥作用了。


​            

       2. 悲观锁    



        操作方式：
    
                查询账户数据：
    
                    SELECT BALANCE … FROM ACCOUNT FOR UPDATE WITH RS
    
                 计算余额:
    
                        POST_BALANCE = BALANCE + AMOUNT
    
                        或者
    
                        POST_BALANCE = BALANCE - AMOUNT
    
                更新账户余额：
    
                        UPDATE …. BALANCE = POST_BALANCE,VERSION = VERSION +1 WHERE ID = ? 
    
                插入账户历史:
    
                        INSERT …

 






        优点：
    
                成功率高；
    
                性能好；
    
                在内存里可以完成很多复杂操作（余额签名）；
    
        缺点：
    
                会存在阻塞，响应时间长；
    
                数据库压力大；

 






        一般应对方案：
    
                采用信号量做热点账户资源使用限制，可以控制数据库压力，为数据库分压，且保持在一个客观的性能水平。



        个人看法：
    
                这种方式能解决大部分的热点账户问题，也是本人之前采取的方式，不过偶尔会存在的超时问题也仅仅是一两笔，其余的都会被信号量拒绝了。


​        

        3.数据库行级锁1



        操作方式：
    
               更新余额:
    
                    入账:
    
                            UPDATE BALANCE = BALANCE +AMOUNT WHERE ID = ?
    
                    扣款：
    
                            UPDATE BALANCE = BALANCE - AMOUNT WHERE ID = ? AND BALANCE > AMOUNT
    
               读取账户数据:（读取数据是为了在账户历史插入的时候保留发生后余额）
    
                            SELECT * FROM ACCOUNT WHERE ID = ? WITH CS 
    
               插入数据
    
                            INSERT ...

 






        优点：
    
                成功率高；
    
                性能好（相对于2）；
    
                数据库压力也会小（相对于2）；
    
                相应时间也小（相对于悲观锁）；
    
        缺点：
    
                一些复杂的操作无法在内存完成了（余额签名）

 






        一般应对方案：
    
                复杂的操作异步化，延迟也就是毫秒级别，或者舍弃签名

 






        个人看法：
    
                这种方式与悲观锁相比好了很多，数据库压力小，性能高了，许增加上单账户限流或者信号量，防止单账户暴涨的量把数据库压爆。

 






        4.数据库行级锁2



        操作方式：
    
                更新余额:
    
                    入账:
    
                            UPDATE BALANCE = BALANCE +AMOUNT WHERE ID = ?
    
                    扣款：
    
                            UPDATE BALANCE = BALANCE - AMOUNT WHERE ID = ? AND BALANCE > AMOUNT
    
                插入数据
    
                            INSERT …
    
                异步更新发生后余额：（或者根据业务情况不需要该步骤）
    
                            UPDATE  ACCOUNT_HISTORY SET POST_BALANCE = ? WHERE  ACCOUNT_ID =?
    
        优点：
    
                成功率高；
    
                性能好（相对于3）；
    
                数据库压力也会小（相对3）；
    
                相应时间也小（相对3）；
    
        缺点：
    
                代码复杂度高，需要异步化一些处理；

 






        个人看法：
    
                一些非核心部分的修改及操作，不需要就去掉，需要的话那就异步处理下。


​            金融账户系统的特点是并发量大、响应快、交易金额大，热点账户问题突出。一个合格的账户系统既要解决上述问题，又必须绝对保证资金安全。

## 记账分录

### 充值

借方：三方支付待清算账户（+）

贷方：个人余额账户（+）

三方支付的待清算账户是热点账户，频繁的增加余额。

### 提现

借方：个人余额账户（-）

贷方：三方支付资产账户（-）

三方支付的资产账户是热点账户，频繁的减少余额。

### 服务费收款

借方：个人账户（-）

贷方：商户服务费账户（+）

商户服务费账户就是热点账户，会频繁增加余额。

### 服务费付款

借方：商户服务费账户（-）

贷方：个人账户（+）

商户服务费账户就是热点账户，会频繁减少余额。

记账时，所有涉及的账户余额都要做update更新，高并发情况下，当出现上述类型的热点账户时，由于数据库的行级锁，对同一账户的更新余额操作由并行变成串行，单个请求的响应时间变长，从而拖垮整个记账服务。

## 解决思路

把热点账户按照金额变动方向分为三种账户：

- 加频账户（余额增加频繁）
- 减频账户（余额扣减频繁）
- 双频账户（余额增加扣减均频繁）

### 加频账户 

采用准实时更新余额，先将金额变动插入临时表中，由定时任务按照一定频率汇总发生额，并更新账户余额，而后删除临时记录。

当加频账户减钱余额不足时，主动去汇总发生额。需要考虑主动汇总发生额和定时任务处理的并发情况，在该定时任务执行时设置redis锁，防止并发。主动汇总时会去判断这个redis锁是否存在，如存在证明定时任务正在执行，无需主动汇总，可能是真的余额不足。

主动汇总同样会设置redis锁，定时任务同样会判断。

### 减频账户 

将减频账户拆分多个子账户，减频子账户设置金额报警，如果某个减频子账户余额不足触发报警，会对该子账户做资金归集，将其他子账户余额归集到该子账户（每个子账户设置可归集金额限制）。

如在交易过程中发现该子账户余额不足，转向使用其他子账户记账。由于拆分子账户，余额查询时需要汇总各个子账户余额返回。记录主账户流水需要记账后余额，这里需要异步计算汇总。当减频账户加钱时，需要平均分配入账到不同的子账户。

### 双频账户 

将双频账户拆分多个子账户。加钱时，准实时更新余额，先将子账户金额变动插入临时表中，由定时任务按一定频率汇总发生额，将汇总的发生额更新进对应的子账户，并删除金额变动记录。减钱按照之前减频账户的逻辑执行。

## 记账死锁问题

高并发情况下，当多个账户之前互相转账时，可能会出现死锁问题。

A账户和B账户双方转账请求并发，账户系统对每个转账请求都会更新A、B余额，这两个更新需要在一个事务里，正常流程线程1先更新A，再更新B，线程2先更新B，再更新A，线程1更新完A后会等待B的锁，不提交事务，线程2更新完B后会等待A的锁，不提交事务，这样两个线程互相等待锁，造成死锁。

### 思路 

解决死锁的最好办法就是避免死锁，避免死锁要从产生死锁的条件入手:

- 互斥：共享资源X和Y只能被一个线程占用
- 占有且等待：线程T1已经取得共享资源X,在等待共享资源Y的时候,不释放共享资源X
- 不可抢占：其他线程不能强行抢占T1占有的资源
- 循环等待：线程T1等待线程T2占有的资源,线程T2等待线程T1占有的资源,就是循环等待

四个添加同时满足就会产生死锁，只要能破坏掉有一个条件，死锁就不会产生。共享资源是没有办法破坏，也就是说互斥是没有办法解决。

### 破坏占用且等待

只需要同时申请资源就可以，同时申请这个操作是一个临界区，需要一个Java类来管理这个临界区，同时申请资源apply()和同时释放资源free()。

通过增加一个 Allocator 账号管理员对象，并且将其设置为单例，每次进行转账的时候，我们都先通过 Allocator 分配账号，如果分配账号成功，则进行转账，如果失败则重新获取，可以设置一个失败次数或是超时时间，达到失败次数或超时时间则转账失败。

### 破坏不可抢占条件

对于不可抢占，可以获取了部分资源，再进一步获取其他资源时如果获取不到时，把已经获取的资源一起释放掉。

java.util.concurrent中的Lock接口，提供了如下三种设计思想都可以解决死锁的不可抢占条件：

- 能够响应中断：线程处于阻塞状态时可以接收中断信号。我们便可以给阻塞的线程发送中断信号，唤醒线程，线程便有机会释放它曾经拥有的锁。这样便可破坏不可抢占条件。
- 支持超时：如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。
- 非阻塞地获取锁：如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也可以破坏不可抢占条件。

### 破坏循环等待条件 

对于循环等待，可以将需要获取的锁资源排序，按照顺序获取，这样就不会多个线程交叉获取相同的资源导致死锁，而是在获取相同的资源时就等待，直到它释放。比如根据账号的主键 id 进行排序，从小到大的获取锁，这样就可以避免循环等待。

> **热点账户问题**由来已久，一直是账户系统设计中的一个难点和瓶颈！
> 小拽将通过上中下三篇文章，分别介绍下热点账户的产生，解决方案和延伸应用！
> 本篇主要介绍下什么是热点账户？通用财务账户系统如何设计？以及其中的幂等健和链式设计等

## 一、热点账户问题

### 1.1 什么是热点账户

**热点账户**：顾名思义，热点账户就是会被高频操作的账户！相较于普通的账户，热点账户数量不多，但操作频率极高！

热点账户从产生来源可分两大类：

- **富二代型**：从产生之初就是热点账户，非常稳定。例如**财务中公司的账户**，每一笔资金操作都要经过公司出金账户，自然而然操作就会灰常频繁，此类账户还包括：**大V账户**，**大KA账户**等等，此类账户所引起的问题是本文重点要解决的
- **暴发户型**：本身是普通账户，由于热点问题变为热点帐户。例如**微博出轨女猪脚账户**，**诺贝尔奖获得者**等等，由于热点事件造成的短时间内访问暴增！此类热点账户防不胜防，超出本文的攻击范围，暂不讨论。

### 1.2 热点账户问题

热点账户一旦产生便伴随着**高并发，流量分布不均匀，高一致性**等等问题。在实际场景中是热点账户必然存在，常常成为用户系统的瓶颈！
同时，热点账户问题也是高并发问题的延展，由于热点的不规则性，如何在高并发情况下，削峰填谷，弹性抗压也是很有挑战性的一个方向！

### 1.3 热点账户通用解决方案的价值

热点账户除了是账户体系的一个通用问题，在高并发，流量分布不均匀，异常峰值等其他问题上，也有一定的通用性。例如**微博热点问题，支付宝双11弹性变更，高频抢购问题**等等。期望通过学习热点账户的八种解决方案，能够举一反三，应用于不同场景！

## 二、如何设计一个财务账户

在解决热点账户问题之前，先来看下如何设计一个简单的财务账户，来保障资金记账的安全！

### 2.1 业务场景分析

从业务上看，财务账户需要**准确记录用户的资金变动过程和结果**！因此设计一个简单财务账户至少要能包括两个部分：**账户余额**和**账户流水**

便于理解，来张传统的账本，看下什么是流水，什么是余额
[![finance_hot_account_1](http://cuihuan.net/wp_content/new/finance/finance_hot_account_1.png)](https://link.segmentfault.com/?enc=xLtu9iUoFN5WB2zTpLdnNw%3D%3D.dbIk0IeECbYaY0P8W0a6BmGf7MyH1DP347ldHqHM1hyMvGx1BqNUKl94oa3uCaNpqRjn06gVvoTTu7wmyxCVxQTVBO7jZv11Ef5GfPsnj3I%3D)

**账户流水**：账户流水也就是通俗意义上的帐或者账单！针对某个账户，每一笔资金的变更都需要记录下来，并且保障**准确，不可更改**！同时如图所示，流水中需要包含单据产生的原因，来源，变更额等等

**账户余额**：账户余额记录用户某个场景账户的当前资金额度！在复杂的业务场景中往往需要拆分出不同的子账户和账户模型。例如，未结算子账户，可提现子账户，冻结子账户，授信账户等等。

从业务场景上一个账户系统核心需要准确记录余额和流水，同时，必须保障记录的**准确，完备，不可变更**!

### 2.2 技术层面拆解

#### 2.2.1 基本表方案

通过业务场景初步分析，基本的账户系统，需要三张基本表

```elixir
账户基本信息：账户信息表
子账户余额信息：账户余额表
账户流水信息：账户流水表

三张表基本关系
账户信息表 1:N 账户余额表
账户余额表 1:N 账户流水表

## 具体账户和用户的关联可以参考三户模型 
```

#### 2.2.2 表字段设计

从技术层面看，设计具体表细节关键要解决以下几个问题

1. 防重：幂等健设计
2. 防改：链式设计
3. 防错：销账设计

先上结果，简单的，能够满足上述需求的设计可以参考innodb mvcc，核心表字段如下

[![finance_hot_account_2](http://cuihuan.net/wp_content/new/finance/finance_hot_account_2.png)](https://link.segmentfault.com/?enc=rNa0iOUe1bTtH8X3cazEsQ%3D%3D.yU4EQrq7C%2FOAGDFudw1b%2F3p0bPUH9sOXtli2r32R8NXECU%2BpFRpib5g8RnA4Mmz7ssQbCHjpYLwA%2FxLGNQrDkWTalZJVmg20M1XE9x7ZiM8%3D)

#### 2.2.3 表字段解读

##### 2.2.3.1 幂等健设计

通过三个属性**资金凭证号+版本号+rollback**三个字段作为uniq key来保证幂等！

**资金凭证号**：来自业务方，业务方发起资金操作的唯一财务凭证，必须可追溯上游凭证和对账！
**版本号**：每次获取DB最新流水n后，版本号n+1插入，保障在并发情况下，每个子账户只有唯一一个版本号：n+1条记录能够插入成功！
**rollback**：回滚标识，保证每条记录**能且只能销账一次**！

对于幂等建设计此处有三条小技巧

1. **上游产生**：每一个幂等健如果可能的话，尽可能的上游产生，这样可以最大限度的避免自产生幂等健的重复问题。如果确实不能上游产生，例如订单ID，提现单ID，那么也尽可能的分阶段产生，例如提现时，先生成提现单ID，真正提现操作的时候，一定是带着提现单ID和信息来的，防止重复造成资损！
2. **业务关联**：幂等健的产生可以用ice生成，但是，最好能够和业务关联，因为通过业务强关联的幂等健可以无限回溯来容灾！比如，a用户的b订单进行c操作，uniq_key = a_b_c的话，也就是在任何情况下，无论多少次回溯，重试也只会有一个唯一的a_b_c，而ice生成则可能造成自回溯的时候插入多条！
3. **写库保证**：这条原则是高一致高并发的基本原则！因为读取a，校验a，然后插入，必然会存在读写之间a变了，或者主从延时a已经变了，读了历史a。因此，幂等一定要通过写库保证或者最底层保证

##### 2.2.3.2 链式设计

链式设计是保证操作精准不可篡改的非常有效手段！
通过资金的**before info，after info，版本号**三个要素来保证一条资金记录一旦插入成功，前后置信息固化！

链式设计的情况下单条修改是不可能的，多条修改需要在保证条目不变的情况下重组资金，但是，整体资金不可变

解决多条修改的一般方案：分布式存储，选举来判定最终正确的链，来确认是否某条链发生了过程修改，这种设计有一个很时髦的名字：**区块链**！而每条流水的核心信息加密后也有了一个更加时髦的名字：**比特币**！

##### 2.2.3.3 销账设计

销账设计在账户系统中是一直存在的，现实财务系统可以**红销蓝抵**，线上财务系统加了链式之后，基本上就只能采用**蓝抵**
通过增加rollback字段，并且严格限制0|1，保证一条账务流水只能被抵销一次！

具体三张表详细字段，需要脱敏，就不贴了，参考上面，其中索引，字段大小，联合索引等设计根据自身业务场景兼容即可！

## 小结：欲知后事如何，且听下回分解

本部分简单介绍了什么是热点账户和账户的基本设计，涵盖幂等健设计，链式设计等等！
下一篇重点分析下热点账户在链式设计下的问题，产生原因和八种基本解决方案

### 一、热点账户的定义

在银行或者第三方支付系统的账务数据库的处理中，数据从一个账户转出，或者有数据转入一个账户，账户都会收到记账请求，并都有一个记账处理的过程。记账处理过程主要包括两部分，一是记录记账凭证，二是更新账户的余额。为了保证账户不被其他请求影响数据的准确性，在进行记账处理时，会先对账户的资源加锁，记账处理完毕后会自动释放锁。随着账务处理业务量的增大，账务数据库中的账户常常会在瞬间产生多个并发操作，但所有对应的并发线程中只有一个线程能够持有当前账户的资源锁，其他线程必须等待该锁被释放后再逐一进行记账处理，这样该账户将会被频繁加锁释锁，使该账户成为账务数据库热点，产生性能瓶颈点，严重影响账务数据库的性能。

### 二、解决方案

从上面热点账户的定义中，我们可以知道解决热点账户带来的数据库性能问题就是要解决高并发环境下数据库锁争用问题。

#### 1.并发度控制

同一时刻，对同一账户修改的请求数越多，这个账户的所等待问题就越严重，所谓*并发度控制*就是要控制同一时刻对热点账户请求的数量，可以通过控制上游支付系统并发请求数据或者账务系统处理的并发请求数来实现。
 　这一方案的缺点是对业务是有损的，当热点账户出现的时候，支付或者账务处理失败率会增加，用户的体验会变差，较大的银行或者第三方支付公司用地比较少。

#### 2.汇总明细记账

实时的交易全部是insert账务明细（insert的开销很小，能够支持高并发。如果基于分布式部署，insert的并发容量理论上可以无限大），然后定时(比如每半个小时)将之前半个小时内的账务明细sum出一个结算总金额，一笔入账结算到指定账户。
 　这个方案的缺点就是：交易不能实时入账，其实如果控制好定时汇总入账的频度，比如分钟级，用户也是可以接受的。这种方式对收单类业务（账户加钱）非常实用，但是对支出类业务（账户减钱）类来说，有账户透支地风险。

#### 3.缓冲入账

将实时同步的记账请求进行异步化，以达到记账实时性和系统稳定性之间平衡的记账手段，这就是”削峰填谷“。
 　详细地讲，假如账务系统对同一个账户的处理阈值为100笔/s，24小时不间断服务(一天能处理86400000笔)。当业务高峰期来临的时候，热点账务的请求数会达到200笔/s。当账户的交易低于100笔/秒的时候，账务系统几乎还是实时地处理了记账请求，而当交易大于100笔/秒的时候，账务系统先返回结果，把账务处理丢到可靠的处理队列中，等并发量不大的时候慢慢消化，对用户来说感受到的体验还是很快就记账成功了。
 　这个方案是有个前提是：热点账户在某几个高峰时间点需要缓冲记账来削峰填谷，并且能在日间填完。一旦账户的日间交易量暴增，导致日间队列根本来不及消化，整个队列越来越长，那就不存在谷可以填，这时候肯定会带来用户大量的投诉。另外这种方案对支出类业务（账户减钱）来讲，也会有账户透支地风险。

#### 4.热点账户锁分散

具体来讲就是创建与热点账户对应的多个影子账户，所述影子账户与所述账户的数据结构相同，将所述影子账户设置为隐藏，并将所述账户的余额分散至各个影子账户。当账务系统接收到账务请求的时候，通过前置进行hash分配（具体的hash函数会有更多方案）选择影子账户进行记账，这样就将原来对一个账户的请求分散到多个影子账户中，分散了账务热点。
 　这个方案也有缺点：通过算法选择的影子账户扣款，影子账户的余额可能是不足的，但账户的总余额是够的，这样可能影响账务处理的成功率。

#### 5.提高服务锁并发能力

提高单台数据库服务器处理能力（I/O,CPU,memory）或者选取内存数据库实时地处理记账请求，然后异步地存储到可靠数据库上。

以上是一些用于解决热点账户问题的常用技术，大家可以根据自己应用场景来解决系统中的热点账务问题，大家可能会有更好地解决方案，大家在积极留言评论，一起学习，共同进步。



作者：MavericksJi
链接：https://www.jianshu.com/p/5f18dff6787a
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

授信

百度百科

授信是指[商业银行](https://baike.baidu.com/item/商业银行/365199)向非[金融机构](https://baike.baidu.com/item/金融机构)客户直接提供的资金，或者对客户在有关经济活动中可能产生的赔偿、支付责任做出的保证，包括贷款、贸易融资、票据融资、融资租赁、透支、各项垫款等表内业务，以及票据承兑、开出信用证、保函、备用信用证、信用证保兑、债券发行担保、借款担保、有追索权的资产销售、未使用的不可撤销的贷款承诺等表外业务。简单来说，授信是指银行向客户直接提供资金支持，或对客户在有关经济活动中的信用向第三方作出保证的行为。



## 原则

[商业银行](https://baike.baidu.com/item/商业银行)对其业务职能部门和[分支机构](https://baike.baidu.com/item/分支机构)所辖服务区及其客户授信，应遵循以下原则：

（一）应根据不同地区的经济发展水平、经济和金融管理能力、[信贷](https://baike.baidu.com/item/信贷)资金占用和使用情况、金融风险状况等因素，实行区别授信。

（二）应根据不同客户的经营管理水平、[资产](https://baike.baidu.com/item/资产)负债比例情况，贷款偿还能力等因素，确定不同的[授信额度](https://baike.baidu.com/item/授信额度)。

（三）应根据各地区的金融风险和客户的信用变化情况，及时调整对各地区和客户的授信额度。

（四）应在确定的授信额度内，根据当地及客户的实际资金需要、还款能力、[信贷政策](https://baike.baidu.com/item/信贷政策)和银行提供贷款的能力，具体确定每笔贷款的额度和实际贷款总额。授信额度不是计划贷款额度，也不是分配的贷款规模，而是[商业银行](https://baike.baidu.com/item/商业银行)为控制地区和客户风险所实施的内部控制贷款额度。

信贷业务经营状态的好坏将直接影响银行的经营业绩,信贷资产质量将直接决定银行的资产结构

授信额度管理是商业银行信贷业务的重要组成部分,是针对银行客户的授信额度的维护,使用,恢复进行集中统一管理的平台,



银行信贷管理系统从功能上分

客户管理系统 授信额度管理

放款中心系统

风险资产管理系统

台账系统

上报人民银行系统

公共控制管理系统

以及其他功能

(1)确定限额

(2) 智能管理

(3)建立大客户专管制度



授信额度管理是根据公司客户资料 行业背景 

信用记录等自然信息,对公司企业进行授信评估

其主要任务是为公司客户设立授信额度

并对授信额度进行维护,使用和恢复等一系列操作,对客户额度

进行集中统一管理

主要包括

1.授信额度控制

建立额度信息数据,提供额度信息业务规则校验

处理流程审批结果,生成有效申请授信额度

处理放款中心业务,提供授信额度使用接口

合同额度提用接口

建立合同额度 凭证提用额度,并根据实际业务情况控制业务的还款等操作

提供外部系统额度使用服务,比如查询统计等

2.授信额度维护

根据维护额度功能列表内容,发起额度维护任务

对一般客户和集团客户的额度设定和调整

根据实际情况冻结和解冻客户授信额度

对客户授信额度进行清零以及清零恢复操作

根据业务要求修改授信额度利率

对客户授信额度进行定期监控

3.授信额度查询

主要提供客户额度数据查询功能

能够查询客户额度 集团额度 提供按照部门进行额度查询功能

4.统计

对额度申请业务进行统计工作,提供开门类报表

余额类报表

业务发生额报表

5系统维护

授信品

利息收取频率  费用收取频率 清零延迟 分行业限额 分行授信

资本金额

6 授信额度预警

额度不足 逾期 垫款 额度到期 监控到期 额度清零 跨行授信预警 超业务限额预警

7 批量处理

异常额度维护

错误数据处理





**监控是为了能让系统维护人员快速发现生产问题并定位到原因。**

**告警的类型**有：

- **批处理效率**：包括日终跑批处理效率和数据处理效率。需要配置超时阀值及监控。
- **流量监控**：主要监控的指标有：TPS（每秒完成事务量）、HPS（每秒服务端收到的请求数）、IOPS（单位时间内系统能处理的IO请求数量）、QPS（每秒服务端响应客户端的查询数量）。
- **异常监控**：程序异常等，可以记录失败响应码及相关的报错信息到日志中。
- **资源利用率**：生产环境配置系统资源时需要对系统资源利用率有一个预测，比如redis何时会耗尽内存，数据库何时会用光磁盘，需要在资源达到饱和前设置阀值，提前做好系统扩容。

监控系统需要考虑几个指标：

1. 根据监控目标来指定监控指标采样频率，频率过高会增加监控成本。
2. 监控覆盖了最好能覆盖所有核心指标。
3. 监控需要注意有效性，不是越多越好。
4. 需要注意告警时效，不同的告警应有不同的应对时效，不是所有告警都需要开发人员马上处理。
5. 为避免长尾效应，最好不要使用平均值。

服务稳定性治理（至今）

1.核心业务链路梳理，业务模块分级，依赖关系梳理，依赖Jar包关系管理，异步解耦，环状依赖等

P0  基础组件系统（数据库 Redis Zookeeper等）

P1  核心业务（用户登录 金融产品 风控 订单  放款 账户）

P2  非核心业务（报表等信息）

P3  内部管理系统监控系统等



在定义了服务分级之后，我们有如下的一些基本原则：

- 下层服务不能直接调用上层服务
- 下层服务稳定性可用性不能受限于上层服务
- 同层级服务之间尽可能保持逻辑隔离
- 底层服务只提供基础能力，并保持模型稳定

依赖关系：

如何梳理服务的依赖关系

微服务的个数100多个

2.监控告警工单报表等推动优化微服务性能摸底、JVM资源调优

1.SQL优化  接口优化 

2.JVM资源优化等

3.网关限流等信息

4.生产环境故障处理

5.错误信息处理TraceId等信息，错误信息规范

错误提示或错误日志要能体现出具体原因



大数据监控告警系统

Skywalking Prometheus  Flink kafka ES  Grafana

1、从0-1打造调用链路画像系统，提供优化参考建议：sql、dubbo基本画像，链路长度，重复调用，循环依赖等 

2、打造一个简化的报警、工单系统：接入核心业务监控指标，系统问题自主发现率从0提升到30%

3、日志系统优化：制定日志规范，解决日志乱的问题；解决Kibana日志不完整问题 

4、基础设施全面监控：中间件、服务器、网络时延等全方位监控

5、BCP平台技术方案制定：给出框架，采集规则与校验结果

6、traceId端透出：准确提供故障现场，减少沟通成本，更快定位问题  -- 10.13已上线

7、性能优化：慢请求治理：优化掉web层90% 4S以上的请求





实时监控系统

背景：为了提高服务的稳定性，梳理服务依赖以及依赖的合理性,快速定位及解决问题和服务未来的容量规划，

需要一套基于云原生的开源监控平台

功能开发：1.数据的采集和存储=》日志和链路和业务监控信息的采集

​                    2.告警监控=》规则库配置，

​                     3.告警管理=》告警路由，分组，抑制，静默，根因分析

​                     4.行动管理=》分派 升级 用户组 节假日 值班组 钉钉 邮件 短信webHook配置



BCP业务核对系统和分布式事务解决方案



如何实现BCP业务核对 SQL层面





分布式环境路由系统

Skywalking



重构风控系统

SSM+Drools



系统优化和改造

消息系统重构Kafka ActiveMQ

金融产品=》计算引擎的引入Aviator







# 项目

项目名称 :  DevOps平台

项目时间 :  2018.09-2019.01 

项目技术 :  GitLab+Maven+Docker+K8s+SpringBoot

项目描述 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理、项目管理、分支管理、环境管理、代码托管、持续交付、微服务治理、线上反馈的开发全生命周期。

工作内容 :  DevOps平台需求分析和现有CI/CD流程梳理。需求管理。项目管理。分支管理。Docker镜像打包和K8s平台对接的开发工作。

 工作内容：DevOps平台需求分析和现有CI/CD流程梳理。产品需求提出阶段的需求管理。

需求管理：

环境管理：

分支管理：gitlab项目模型

如何打包：

项目完整流程：

需求=》设计=》开发=》测试=》部署=》发布

产品需求

gitlab源码以及项目分支，中间件

环境  部署

build   构建脚本

​              





项目名称 :  服务稳定性治理

项目时间 :  2021.10-至今

项目技术 :  Skywalking+Prometheus+Grafana+SpringBoot+RocketMQ+Dubbo

项目描述 :  微服务技术栈升级和改造。

工作内容 :  微服务技术栈升级和改造。

 

 

项目名称 :  全链路监控和告警系统

项目时间 :  2018.09-2019.01 

项目技术 :  Skywalking+Prometheus+Grafana+Flink+ES

项目描述 :  基于Skywalking的全链路Trace监控和展示。基于Prometheus的Metric指标项监控。ELK日志平台监控。基于Flink的数据采集和告警。

工作内容 :  基于Skywalking的链路监控。基于Prometheus的Metric指标项监控。ELK日志平台监控。基于Flink的数据采集和告警。

 

项目名称 :  分布式环境路由

项目时间 :  2018.09-2019.01 

项目技术 :  Skywalking+JavaAgent+ByteBuddy+Dubbo+RocketMQ+SpringMVC

项目描述 :  打造统一的环境支持，项目可以本地调试，基础环境进行统一。

工作内容 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

 

 

项目名称 :  授信系统重构

项目时间 :  2018.09-2019.01 

项目技术 :  Skywalking+JavaAgent+ByteBuddy

项目描述 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

工作内容 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

 

 

项目名称 :  风控评分卡重构

项目时间 :  2018.09-2019.01 

项目技术 :  Skywalking+JavaAgent+ByteBuddy

项目描述 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

工作内容 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

 

 

 

项目名称 :  动动兔运动云平台

项目时间 :  2018.09-2019.01 

项目技术 :  Skywalking+JavaAgent+ByteBuddy

项目描述 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

工作内容 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

 

 

项目名称 :  金融助贷云平台

项目时间 :  2018.09-2019.01 

项目技术 :  Skywalking+JavaAgent+ByteBuddy

项目描述 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

工作内容 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

 

 

项目名称 :  分布式任务调度平台

项目时间 :  2018.09-2019.01 

项目技术 :  Quartz+Dubbo

项目描述 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

工作内容 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

 

 

 

 

项目名称 :  分布式日志追踪标记系统

项目时间 :  2018.09-2019.01 

项目技术 :  Skywalking+JavaAgent+ByteBuddy

项目描述 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

工作内容 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

 

 

 

项目名称 :  多渠道支付路由系统

项目时间 :  2018.09-2019.01 

项目技术 :  Skywalking+JavaAgent+ByteBuddy

项目描述 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

工作内容 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

 

 

 

项目名称 :  账户系统

项目时间 :  2018.09-2019.01 

项目技术 :  Skywalking+JavaAgent+ByteBuddy

项目描述 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

工作内容 :  构建企业云原生DevOps体系，打造研发运维管理一体化平台。整个方案涵盖了需求管理-项目管理-分支管理-代码托管-持续交付-微服务治理-线上反馈的开发全生命周期。

 

 

项目名称 :  信审系统

项目时间 :  2018.09-2019.01 

项目技术 :  Spring+Mybatis+SpringMVC+Drools+Activiti

项目描述 :  贷审团队日常审核作业流程的支撑系统，提供黑名单匹配、风险识别、信用评分、自动分单、流程跳转和业务规则配置等服务，支持网查、面审、调查、终审、复核等审批操作，严格管理作业人员功能权限和数据权限，同时提供绩效统计、作业时效、库存统计等报表生成工具。

工作内容 :  负责日常审批流程的开发和日常维护，用于支撑业务的初审、终审、复核等审批操作。负责黑名单系统的开发和维护工作。负责信用评分规则引擎的开发和维护。



